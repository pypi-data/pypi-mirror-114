{"version":3,"sources":["repositoryCommitsCollection.es6.js"],"names":[],"mappings":";;AAAA;;;;;;;AAOA,GAAG,iBAAH,GAAuB,GAAG,cAAH,CAAkB,MAAlB,CAAyB;AAC5C,WAAO,GAAG,gBADkC;;AAG5C;;;;;;;;;;;;;;;;;;;;AAoBA,cAvB4C,sBAuBjC,MAvBiC,EAuBzB,OAvByB,EAuBhB;AACxB,iBAAS,UAAT,CAAoB,SAApB,CAA8B,UAA9B,CAAyC,IAAzC,CAA8C,IAA9C,EAAoD,MAApD,EAA4D,OAA5D;AACA,aAAK,OAAL,GAAe,OAAf;AACA,aAAK,IAAL,GAAY,KAAZ;AACA,aAAK,QAAL,GAAgB,KAAhB;AACA,aAAK,UAAL,GAAkB,IAAlB;AACH,KA7B2C;;;AA+B5C;;;;;;;;;;;AAWA,SA1C4C,iBA0CtC,QA1CsC,EA0C5B;AACZ,YAAM,UAAU,SAAS,OAAzB;;AAEA,aAAK,UAAL,GAAkB,QAAQ,QAAQ,MAAR,GAAiB,CAAzB,EAA4B,MAA9C;AACA,aAAK,QAAL,GAAgB,CAAC,KAAK,UAAtB;;AAEA,eAAO,SAAS,OAAhB;AACH,KAjD2C;;;AAmD5C;;;;;;;AAOA,OA1D4C,iBA0DtC;AACF,YAAM,SAAS,EAAf;;AAEA,YAAI,KAAK,OAAL,CAAa,KAAb,KAAuB,SAA3B,EAAsC;AAClC,mBAAO,KAAP,GAAe,KAAK,OAAL,CAAa,KAA5B;AACH;;AAED,YAAI,KAAK,OAAL,CAAa,MAAb,KAAwB,SAA5B,EAAuC;AACnC,mBAAO,MAAP,GAAgB,KAAK,OAAL,CAAa,MAA7B;AACH;;AAED,eAAO,KAAK,OAAL,CAAa,OAAb,GAAuB,GAAvB,GAA6B,EAAE,KAAF,CAAQ,MAAR,CAApC;AACH,KAtE2C;;;AAwE5C;;;;;;;;;;;;;;AAcA,gBAtF4C,0BAsF7B;AACX,eAAO,CAAC,KAAK,IAAN,IAAc,CAAC,KAAK,QAApB,IAAgC,KAAK,MAAL,CAAY,MAAZ,GAAqB,CAA5D;AACH,KAxF2C;;;AA0F5C;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA,aAtH4C,uBAsHtB;AAAA;;AAAA,YAAZ,OAAY,uEAAJ,EAAI;;AAClB,YAAI,KAAK,YAAL,EAAJ,EAAyB;AACrB,iBAAK,OAAL,CAAa,KAAb,GAAqB,KAAK,UAA1B;;AAEA,iBAAK,KAAL,CAAW;AACP,wBAAQ,KADD;AAEP,yBAAS,mBAAM;AACX,0BAAK,IAAL,GAAY,KAAZ;;AAEA,wBAAI,EAAE,UAAF,CAAa,QAAQ,OAArB,CAAJ,EAAmC;AAC/B,gCAAQ,OAAR;AACH;AACJ,iBARM;AASP,uBAAO,QAAQ;AATR,aAAX;AAWH;AACJ;AAtI2C,CAAzB,CAAvB","file":"repositoryCommitsCollection.js","sourcesContent":["/**\n * A collection of commits in a repository.\n *\n * This is expected to be used in an ephemeral manner to get a list of commits\n * from a given start point (usually corresponding to some branch in the\n * repository).\n */\nRB.RepositoryCommits = RB.BaseCollection.extend({\n    model: RB.RepositoryCommit,\n\n    /**\n     * Initialize the collection.\n     *\n     * Args:\n     *     models (Array of object):\n     *         Initial models for the collection.\n     *\n     *     options (Object):\n     *         Options for the collection.\n     *\n     * Option Args:\n     *     start (string):\n     *         The start commit for fetching commit logs.\n     *\n     *     branch (string):\n     *         The branch name for fetching commit logs.\n     *\n     *     urlBase (string):\n     *         The base URL for the API request.\n     */\n    initialize(models, options) {\n        Backbone.Collection.prototype.initialize.call(this, models, options);\n        this.options = options;\n        this.busy = false;\n        this.complete = false;\n        this._nextStart = null;\n    },\n\n    /**\n     * Parse the response.\n     *\n     * Args:\n     *     response (object):\n     *         Response, parsed from the JSON returned by the server.\n     *\n     * Returns:\n     *     Array of object:\n     *     An array of commits.\n     */\n    parse(response) {\n        const commits = response.commits;\n\n        this._nextStart = commits[commits.length - 1].parent;\n        this.complete = !this._nextStart;\n\n        return response.commits;\n    },\n\n    /**\n     * Get the URL to fetch for the next page of results.\n     *\n     * Returns:\n     *     string:\n     *     The URL to fetch.\n     */\n    url() {\n        const params = {};\n\n        if (this.options.start !== undefined) {\n            params.start = this.options.start;\n        }\n\n        if (this.options.branch !== undefined) {\n            params.branch = this.options.branch;\n        }\n\n        return this.options.urlBase + '?' + $.param(params);\n    },\n\n    /**\n     * Return whether another page of commits can be fetched.\n     *\n     * A page can only be fetched if there's at least 1 commit already\n     * fetched, the last commit in the repository has not been fetched, and\n     * another fetch operation isn't in progress.\n     *\n     * Version Added:\n     *     4.0.3\n     *\n     * Returns:\n     *     boolean:\n     *     ``true`` if another page can be fetched. ``false`` if one cannot.\n     */\n    canFetchNext() {\n        return !this.busy && !this.complete && this.models.length > 0;\n    },\n\n    /**\n     * Fetch the next page of results.\n     *\n     * This can be called multiple times. If this is called when a fetch is\n     * already in progress, it's a no-op. Otherwise, if there are more commits\n     * to load, it will fetch them and add them to the bottom of the\n     * collection.\n     *\n     * It's up to the caller to check :js:func:`canFetchNext()` before calling\n     * this if they want callbacks to fire.\n     *\n     * Version Changed:\n     *     4.0.3:\n     *     Added the ``options`` argument with ``error`` and ``success``\n     *     callbacks.\n     *\n     * Args:\n     *     options (object, optional):\n     *         Options for fetching the next page of results.\n     *\n     * Option Args:\n     *     error (function):\n     *         A function to call if fetching a page fails. This must take\n     *         ``collection, xhr`` arguments.\n     *\n     *     success (function):\n     *         A function to call if fetching a page succeeds.\n     */\n    fetchNext(options={}) {\n        if (this.canFetchNext()) {\n            this.options.start = this._nextStart;\n\n            this.fetch({\n                remove: false,\n                success: () => {\n                    this.busy = false;\n\n                    if (_.isFunction(options.success)) {\n                        options.success();\n                    }\n                },\n                error: options.error,\n            });\n        }\n    }\n});\n"]}