{"version":3,"sources":["dashboardPageModel.es6.js"],"names":[],"mappings":";;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqCA,GAAG,KAAH,CAAS,aAAT,GAAyB,GAAG,IAAH,CAAQ,MAAR,CAAe;AACpC;;;;;;;AAOA,YARoC,sBAQzB;AACP,eAAO,EAAE,QAAF,CAAW,EAAE,MAAF,CAAS,GAAG,IAAH,CAAQ,SAAR,CAAkB,QAA3B,CAAX,EAAiD;AACpD,yBAAa,IADuC;AAEpD,yBAAa;AAFuC,SAAjD,CAAP;AAIH,KAbmC;;;AAepC;;;AAGA,cAlBoC,wBAkBvB;AACT,WAAG,IAAH,CAAQ,SAAR,CAAkB,UAAlB,CAA6B,KAA7B,CAAmC,IAAnC,EAAyC,SAAzC;;AAEA,aAAK,OAAL,GAAe,IAAI,SAAS,UAAb,EAAf;AACH,KAtBmC;;;AAwBpC;;;;;;;;;;;;;AAaA,eArCoC,uBAqCxB,cArCwB,EAqCR;AACxB,YAAM,aAAa,EAAnB;AACA,YAAM,cAAc,KAAK,GAAL,CAAS,aAAT,CAApB;;AAEA,aAAK,OAAL,CAAa,KAAb;;AAEA,aAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,YAAY,MAAhC,EAAwC,GAAxC,EAA6C;AACzC,gBAAM,aAAa,YAAY,CAAZ,CAAnB;;AAEA,gBAAI;AACA,oBAAI,YAAY,WAAW,WAAW,UAAtB,CAAhB;AACA,oBAAI,WAAW,WAAW,WAAW,SAAtB,CAAf;;AAEA,oBAAI,cAAc,SAAlB,EAA6B;AACzB,gCAAY,QAAQ,eAAR,CAAwB,WAAW,UAAnC,CAAZ;AACA,+BAAW,WAAW,UAAtB,IAAoC,SAApC;AACH;;AAED,oBAAI,aAAa,SAAjB,EAA4B;AACxB,+BAAW,QAAQ,eAAR,CAAwB,WAAW,SAAnC,CAAX;AACA,+BAAW,WAAW,SAAtB,IAAmC,QAAnC;AACH;;AAED,oBAAM,cAAc,IAAI,SAAJ,CAChB,EAAE,QAAF,CACI;AACI,wBAAI,WAAW;AADnB,iBADJ,EAII,WAAW,UAJf,CADgB,EAMhB,WAAW,YANK,CAApB;;AAQA,qBAAK,OAAL,CAAa,GAAb,CAAiB,WAAjB;;AAEA,+BAAe;AACX,2BAAO,WAAW,KADP;AAEX,8BAAU,QAFC;AAGX,iCAAa,WAAW,WAHb;AAIX,iCAAa;AAJF,iBAAf;AAMH,aA9BD,CA8BE,OAAO,CAAP,EAAU;AACR,wBAAQ,KAAR,CACI,iDADJ,EAEI,WAAW,EAFf,EAEmB,CAFnB;AAGH;AACJ;AACJ;AAlFmC,CAAf,CAAzB","file":"dashboardPageModel.js","sourcesContent":["/**\n * State for the administration UI's main dashboard page.\n *\n * Model Attributes:\n *     supportData (string):\n *         An encoded payload containing information used to look up\n *         information on an active support contract for the server.\n *\n *     widgetsData (Array of object):\n *         Metadata on all the widgets rendered on the page. Each entry in\n *         the array is an object containing:\n *\n *         ``id``:\n *             The ID of the widget.\n *\n *         ``domID``:\n *             The DOM element ID of the widget's rendered HTML.\n *\n *         ``modelClass``:\n *             The namespaced name of the model class managing the widget's\n *             state.\n *\n *         ``modelAttrs``:\n *             The optional attributes passed to the widget model during\n *             initialization.\n *\n *         ``modelOptions``:\n *             The optional options passed to the widget model during\n *             initialization.\n *\n *         ``viewClass``:\n *             The namespaced name of the view class rendering the widget.\n *\n *         ``viewOptions``:\n *             The optional options passed to the widget view during\n *             initialization.\n */\nRB.Admin.DashboardPage = RB.Page.extend({\n    /**\n     * Return the default attribute values.\n     *\n     * Returns:\n     *     object:\n     *     The default attribute values.\n     */\n    defaults() {\n        return _.defaults(_.result(RB.Page.prototype.defaults), {\n            supportData: null,\n            widgetsData: [],\n        });\n    },\n\n    /**\n     * Initialize the page.\n     */\n    initialize() {\n        RB.Page.prototype.initialize.apply(this, arguments);\n\n        this.widgets = new Backbone.Collection();\n    },\n\n    /**\n     * Load the widgets from the serialized widget data.\n     *\n     * This will construct a model for each widget, and call the provided\n     * function to finish any UI-side setup.\n     *\n     * If any widgets fail to load, they'll be skipped.\n     *\n     * Args:\n     *     onWidgetLoaded (function):\n     *         The function to call for each widget. This takes the widget\n     *         model and serialized widget information as parameters.\n     */\n    loadWidgets(onWidgetLoaded) {\n        const classTypes = {};\n        const widgetsData = this.get('widgetsData');\n\n        this.widgets.reset();\n\n        for (let i = 0; i < widgetsData.length; i++) {\n            const widgetInfo = widgetsData[i];\n\n            try {\n                let ModelType = classTypes[widgetInfo.modelClass];\n                let ViewType = classTypes[widgetInfo.viewClass];\n\n                if (ModelType === undefined) {\n                    ModelType = Djblets.getObjectByName(widgetInfo.modelClass);\n                    classTypes[widgetInfo.modelClass] = ModelType;\n                }\n\n                if (ViewType === undefined) {\n                    ViewType = Djblets.getObjectByName(widgetInfo.viewClass);\n                    classTypes[widgetInfo.viewClass] = ViewType;\n                }\n\n                const widgetModel = new ModelType(\n                    _.defaults(\n                        {\n                            id: widgetInfo.id,\n                        },\n                        widgetInfo.modelAttrs),\n                    widgetInfo.modelOptions);\n\n                this.widgets.add(widgetModel);\n\n                onWidgetLoaded({\n                    domID: widgetInfo.domID,\n                    ViewType: ViewType,\n                    viewOptions: widgetInfo.viewOptions,\n                    widgetModel: widgetModel,\n                });\n            } catch (e) {\n                console.error(\n                    'Unable to render administration widget \"%s\": %s',\n                    widgetInfo.id, e);\n            }\n        }\n    },\n});\n"]}