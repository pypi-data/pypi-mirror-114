{"version":3,"sources":["floatingBannerView.es6.js"],"names":[],"mappings":"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","file":"floatingBannerView.js","sourcesContent":["/**\n * Floats a banner on screen within a container.\n *\n * The banner will appear at the top of the container, or the screen,\n * whichever is visible, until the container is no longer on-screen.\n *\n * The banner will keep a spacer in its original location at the top\n * of the container in order to reserve space for it to anchor to.\n * This ensures that the page doesn't jump too horribly.\n */\nRB.FloatingBannerView = Backbone.View.extend({\n    /**\n     * Initialize the view.\n     *\n     * Args:\n     *     options (object):\n     *         Options for the view.\n     *\n     * Option Args:\n     *     $floatContainer (jQuery):\n     *         The container to use when the banner is floating.\n     *\n     *     noFloatContainerClass (string):\n     *         The class name used when the banner should not be floating.\n     */\n    initialize(options) {\n        this.options = options;\n        this._$floatSpacer = null;\n\n        _.bindAll(this, '_updateFloatPosition', '_updateSize');\n    },\n\n    /**\n     * Render the banner and listens for scroll and resize updates.\n     *\n     * Returns:\n     *     RB.FloatingBannerView:\n     *     This object, for chaining.\n     */\n    render() {\n        $(window)\n            .scroll(this._updateFloatPosition)\n            .resize(this._updateSize);\n        _.defer(this._updateFloatPosition);\n\n        return this;\n    },\n\n    /**\n     * Remove the view from the DOM.\n     *\n     * This will remove both the banner and the floating spacer (if currently\n     * in the DOM).\n     */\n    remove() {\n        if (this._$floatSpacer !== null) {\n            this._$floatSpacer.remove();\n        }\n\n        Backbone.View.prototype.remove.call(this);\n    },\n\n    /**\n     * Update the size of the banner to match the spacer.\n     */\n    _updateSize() {\n        if (this._$floatSpacer !== null) {\n            if (this.$el.hasClass('floating')) {\n                const rect =\n                    this._$floatSpacer.parent()[0].getBoundingClientRect();\n\n                this.$el.width(\n                    Math.ceil(rect.width) -\n                    this.$el.getExtents('bpm', 'lr'));\n            } else {\n                this.$el.width('auto');\n            }\n        }\n    },\n\n    /**\n     * Update the position of the banner.\n     *\n     * This will factor in how much of the container is visible, based on\n     * its size, position, and the scroll offset. It will then attempt\n     * to position the banner to the top of the visible portion of the\n     * container.\n     */\n    _updateFloatPosition() {\n        if (this.$el.parent().length === 0) {\n            return;\n        }\n\n        if (this._$floatSpacer === null) {\n            this._$floatSpacer = this.$el.wrap($('<div/>')).parent();\n            this._updateSize();\n        }\n\n        const $container = this.options.$floatContainer;\n        const containerTop = $container.offset().top;\n        const containerHeight = $container.outerHeight();\n        const containerBottom = containerTop + containerHeight;\n        const windowTop = $(window).scrollTop();\n        const topOffset = this._$floatSpacer.offset().top - windowTop;\n        const outerHeight = this.$el.outerHeight(true);\n\n        const wasFloating = this.$el.hasClass('floating');\n\n        if (!$container.hasClass(this.options.noFloatContainerClass) &&\n            topOffset < 0 &&\n            containerTop < windowTop &&\n            windowTop < containerBottom) {\n            /*\n             * We're floating! If we just entered this state, set the\n             * appropriate styles on the element.\n             *\n             * We'll then want to set the top to 0, unless the user is\n             * scrolling the banner out of view. In that case, figure out how\n             * much to show, and set the appropriate offset.\n             */\n            if (!wasFloating) {\n                /*\n                 * Set the spacer to be the dimensions of the docked banner,\n                 * so that the container doesn't change sizes when we go into\n                 * float mode.\n                 */\n                this._$floatSpacer\n                    .height(this.$el.outerHeight())\n                    .css({\n                        'margin-top': this.$el.css('margin-top'),\n                        'margin-bottom': this.$el.css('margin-bottom'),\n                    });\n\n                this.$el\n                    .addClass('floating')\n                    .css('position', 'fixed');\n            }\n\n            this.$el.css('top',\n                         windowTop > containerBottom - outerHeight\n                         ? containerBottom - outerHeight - windowTop\n                         : 0);\n\n            this._updateSize();\n        } else if (wasFloating) {\n            /*\n             * We're now longer floating. Unset the styles on the banner and\n             * on the spacer (in order to prevent the spacer from taking up\n             * any additional room.\n             */\n            this.$el\n                .removeClass('floating')\n                .css({\n                    top: '',\n                    position: '',\n                });\n            this._$floatSpacer\n                .height('auto')\n                .css('margin', 0);\n        }\n    },\n});\n"]}