# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'C:\Users\LuckyCat\PycharmProjects\ToGather\framework.ui'
#
# Created by: PyQt5 UI code generator 5.15.4
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.
import datetime
import sys
from functools import partial

from bin.togather_client import *
from PyQt5 import QtCore, QtGui, QtWidgets, QtChart
from PyQt5.Qt import Qt
from PyQt5.QtCore import Qt, QObject, QThread, pyqtSignal
from PyQt5.QtWidgets import QApplication, QMainWindow, QWidget, QDialog
from PyQt5.QtChart import QChart, QChartView, QValueAxis, QBarCategoryAxis, QBarSet, QBarSeries
from PyQt5.uic import loadUi
from PyQt5.QtGui import QMovie
from bin.group import Group
from bin.user import User
from bin.event import Event
from bin.option import Option
from bin.togather_server import *
import bin.eventwidget
import bin.groupwidget
import bin.votingwidget
import importlib.resources as importlib_resources
from qt_material import apply_stylesheet
from bin.message import Message
import time
import bin.perf_element as gensched


def main():
    app = QtWidgets.QApplication(["ToGather"])
    MainWindow = QtWidgets.QMainWindow()
    apply_stylesheet(app, theme='light_teal.xml', invert_secondary=True)
    ui = Ui_MainWindow(MainWindow)
    print()

    # Try to start server.
    # TODO: We need to test this using our nonlocal server.
    try:
        server = StartServer()  # From togather_server module
        server.start()
    except OSError:
        print("Server already started by other local client")

    # Start client.
    address = ("localhost", 55557)
    client = Client(address)
    try:  # Always close connection when failing.
        client.start()
    except:
        Client.exit()
    print("Client started.")

    # Initialize database if it doesn't exist.
    with importlib_resources.path("bin", "circles.ui") as p:
        path = p
    path = os.path.dirname(path)
    if not os.path.isfile(path + "/db.db"):
        Data.create_tables()

    # Load database from the client that is running the server.
    # If this is the client running the server, just reloads the database.
    # Only relevant if two clients are running from separate directories.
    Data.db_request()

    # thread = Thread(target=watch, args=())
    # thread.start()

    # Close client when UI is exited.
    ret = app.exec_()
    if client.is_alive():
        client.exit()
    sys.exit(ret)


class windowPopup(QDialog):
    def __init__(self, name, parent=None):
        super().__init__()
        self.name = name


class Ui_MainWindow(QMainWindow):  # changed to QMainWindow from object

    def __init__(self, MainWindow):
        super().__init__()
        self.update_needed_signal = QtCore.pyqtSignal()
        self.update_monitor = UpdateMonitor()
        self.update_thread = QtCore.QThread(self)
        self.update_monitor.update_signal.connect(self.update_ui)
        self.update_monitor.moveToThread(self.update_thread)
        self.update_thread.started.connect(self.update_monitor.monitor_updates)
        self.update_thread.start()

        self.current_group = None
        self.current_user = None
        self.circlearr = []
        self.messageList = None

        self.MainWindow = MainWindow
        self.setupUi()

    # Function that is called when update signal is received.
    @QtCore.pyqtSlot()
    def update_ui(self):
        print(self.current_group)
        print(self.current_user)

        # self.current_user = None
        # and type(self.current_group) == Group and type(self.current_user) == User:
        if self.current_group is not None:
            if self.current_user is not None:
                if Data.get_groups(self.current_group.name) is not None and Data.get_users(
                        self.current_user.name) is not None:
                    self.update_group(Data.get_groups(self.current_group.name))
                else:
                    print("what up")

        print("Signal received by UI!")
        # TODO: You should be able to access and change UI elements here
        # All UI elements would ideally reflect any changes to the database when the update signal is received.
        # We may have to declare elements in __init__ to access them here? Or as class variables like circlearr above?

        # Example of how UI could be updated.
        # title_string = ""
        # for user in Data.get_users():
        #     title_string += user.name
        #     title_string += " "
        # self.MainWindow.setWindowTitle(title_string)

        # Reset Data.update_UI after UI is updated

        Data.update_UI = False

    def setupUi(self):

        # Main
        self.MainWindow.setWindowTitle("ToGather")
        self.MainWindow.setObjectName("MainWindow")
        self.MainWindow.setFixedSize(1280, 720)
        self.MainWindow.show()
        self.centralwidget = QtWidgets.QStackedWidget(self.MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.mainTab = QtWidgets.QTabWidget(self.centralwidget)
        self.mainTab.setGeometry(QtCore.QRect(0, 0, 1280, 720))
        self.mainTab.setAutoFillBackground(True)
        self.mainTab.setObjectName("mainTab")

        self.splashWindow = SplashScreen(self.MainWindow, self)
        self.centralwidget.addWidget(self.splashWindow)
        self.centralwidget.addWidget(self.mainTab)

        # Home
        self.home_tab = QtWidgets.QWidget()
        self.home_tab.setObjectName("home_tab")
        self.h_usr_label = QtWidgets.QLabel(self.home_tab)
        self.h_usr_label.setGeometry(QtCore.QRect(30, 600, 500, 50))
        self.h_usr_label.setObjectName("h_usr_label")
        self.home_logout = QtWidgets.QPushButton(self.home_tab)
        self.home_logout.setGeometry(QtCore.QRect(1010, 20, 100, 30))
        self.home_logout.setObjectName("home_logout")
        self.home_logout.clicked.connect(self.gotosplash)
        self.background_style = QtWidgets.QLabel(self.home_tab)
        self.background_style.setGeometry(QtCore.QRect(590, 200, 101, 16))
        self.background_style.setObjectName("background_style")
        self.style_button = QtWidgets.QPushButton(self.home_tab)
        self.style_button.setGeometry(QtCore.QRect(440, 250, 118, 34))
        self.style_button.setObjectName("style_button")
        self.style_button.clicked.connect(lambda checked, a=self.MainWindow: self.change_color(a, "none", 0))
        self.teal_button = QtWidgets.QPushButton(self.home_tab)
        self.teal_button.setGeometry(QtCore.QRect(690, 250, 50, 50))
        self.teal_button.setObjectName("teal_button")
        self.teal_button.clicked.connect(lambda checked, a=self.MainWindow: self.change_color(a, "teal", 1))
        self.pink_button = QtWidgets.QPushButton(self.home_tab)
        self.pink_button.setGeometry(QtCore.QRect(750, 250, 50, 50))
        self.pink_button.setObjectName("pink_button")
        self.pink_button.clicked.connect(lambda checked, a=self.MainWindow: self.change_color(a, "pink", 1))
        self.purple_button = QtWidgets.QPushButton(self.home_tab)
        self.purple_button.setGeometry(QtCore.QRect(810, 250, 50, 50))
        self.purple_button.setObjectName("purple_button")
        self.purple_button.clicked.connect(lambda checked, a=self.MainWindow: self.change_color(a, "purple", 1))
        self.red_button = QtWidgets.QPushButton(self.home_tab)
        self.red_button.setGeometry(QtCore.QRect(690, 310, 50, 50))
        self.red_button.setObjectName("red_button")
        self.red_button.clicked.connect(lambda checked, a=self.MainWindow: self.change_color(a, "red", 1))
        self.blue_button = QtWidgets.QPushButton(self.home_tab)
        self.blue_button.setGeometry(QtCore.QRect(750, 310, 50, 50))
        self.blue_button.setObjectName("blue_button")
        self.blue_button.clicked.connect(lambda checked, a=self.MainWindow: self.change_color(a, "blue", 1))
        self.yellow_button = QtWidgets.QPushButton(self.home_tab)
        self.yellow_button.setGeometry(QtCore.QRect(810, 310, 50, 50))
        self.yellow_button.setObjectName("yellow_button")
        self.yellow_button.clicked.connect(lambda checked, a=self.MainWindow: self.change_color(a, "yellow", 1))

        self.home_image = QtWidgets.QLabel(self.home_tab)
        self.home_image.setGeometry(QtCore.QRect(460, 0, 301, 161))
        self.home_image.setObjectName("home_image")
        self.mainTab.addTab(self.home_tab, "")
        self.current_color = "teal"

        # Events + Circles Merger
        self.merger_tab = QtWidgets.QWidget()
        self.merger_tab.setObjectName("merger_tab")
        self.mainTab.addTab(self.merger_tab, "")
        self.merger_group_name = QtWidgets.QLabel(self.merger_tab)
        self.merger_group_name.setGeometry(QtCore.QRect(10, 50, 281, 61))
        font = QtGui.QFont()
        font.setPointSize(24)
        self.merger_group_name.setFont(font)
        self.merger_group_name.setObjectName("merger_group_name")
        self.c_usr_label = QtWidgets.QLabel(self.merger_tab)
        self.c_usr_label.setGeometry(QtCore.QRect(10, 610, 500, 50))
        self.c_usr_label.setObjectName("c_usr_label")
        self.merger_event_scroll = QtWidgets.QScrollArea(self.merger_tab)
        self.merger_event_scroll.setGeometry(QtCore.QRect(10, 145, 801, 471))
        self.merger_event_scroll.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOn)
        self.merger_event_scroll.setWidgetResizable(True)
        self.merger_event_scroll.setObjectName("merger_event_scroll")
        self.merger_event_scroll.setStyleSheet("border: 1px solid black;")
        self.merger_scrollAreaWidgetContents = QtWidgets.QWidget()
        self.merger_scrollAreaWidgetContents.setGeometry(QtCore.QRect(0, 0, 799, 469))
        self.merger_scrollAreaWidgetContents.setObjectName("merger_scrollAreaWidgetContents")
        self.gridLayout_5 = QtWidgets.QVBoxLayout(self.merger_scrollAreaWidgetContents)
        self.gridLayout_5.setObjectName("gridLayout_5")
        self.merger_event_scroll.setWidget(self.merger_scrollAreaWidgetContents)
        self.merger_member_scroll = QtWidgets.QScrollArea(self.merger_tab)
        self.merger_member_scroll.setGeometry(QtCore.QRect(1020, 145, 241, 471))
        self.merger_member_scroll.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOn)
        self.merger_member_scroll.setWidgetResizable(True)
        self.merger_member_scroll.setObjectName("merger_member_scroll")
        self.merger_member_scroll.setStyleSheet("border: 1px solid black;")
        self.merger_scrollAreaWidgetContents_2 = QtWidgets.QWidget()
        self.merger_scrollAreaWidgetContents_2.setGeometry(QtCore.QRect(0, 0, 239, 469))
        self.merger_scrollAreaWidgetContents_2.setObjectName("merger_scrollAreaWidgetContents_2")
        self.gridLayout_6 = QtWidgets.QVBoxLayout(self.merger_scrollAreaWidgetContents_2)
        self.gridLayout_6.setObjectName("gridLayout_6")
        self.merger_member_scroll.setWidget(self.merger_scrollAreaWidgetContents_2)
        self.merger_schedule_button = QtWidgets.QPushButton(self.merger_tab)
        self.merger_schedule_button.setGeometry(QtCore.QRect(240, 90, 132, 40))
        font = QtGui.QFont()
        font.setPointSize(8)
        self.merger_schedule_button.setFont(font)
        self.merger_schedule_button.setObjectName("merger_schedule_button")
        self.merger_schedule_button.clicked.connect(self.gotoschedules)
        self.merger_add_event_button = QtWidgets.QPushButton(self.merger_tab)
        self.merger_add_event_button.setGeometry(QtCore.QRect(380, 90, 132, 40))
        font = QtGui.QFont()
        font.setPointSize(8)
        self.merger_add_event_button.setFont(font)
        self.merger_add_event_button.setObjectName("merger_add_event_button")
        self.merger_add_event_button.clicked.connect(self.gotoaddevent)
        self.merger_switch_group_button = QtWidgets.QPushButton(self.merger_tab)
        self.merger_switch_group_button.setGeometry(QtCore.QRect(520, 90, 132, 40))
        font = QtGui.QFont()
        font.setPointSize(8)
        self.merger_switch_group_button.setFont(font)
        self.merger_switch_group_button.setObjectName("merger_switch_group_button")
        self.merger_switch_group_button.clicked.connect(self.gotoyourcircles)
        self.merger_add_group_button = QtWidgets.QPushButton(self.merger_tab)
        self.merger_add_group_button.setGeometry(QtCore.QRect(660, 90, 132, 40))
        font = QtGui.QFont()
        font.setPointSize(8)
        self.merger_add_group_button.setFont(font)
        self.merger_add_group_button.setObjectName("merger_add_group_button")
        self.merger_add_group_button.clicked.connect(self.gotocreate)
        self.merger_add_member_button = QtWidgets.QPushButton(self.merger_tab)
        self.merger_add_member_button.setGeometry(QtCore.QRect(1125, 90, 132, 40))
        font = QtGui.QFont()
        font.setPointSize(8)
        self.merger_add_member_button.setFont(font)
        self.merger_add_member_button.setObjectName("merger_add_member_button")
        self.merger_add_member_button.clicked.connect(self.gotoadd)
        self.merger_event_header = QtWidgets.QLabel(self.merger_tab)
        self.merger_event_header.setGeometry(QtCore.QRect(20, 120, 61, 20))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.merger_event_header.setFont(font)
        self.merger_event_header.setObjectName("merger_event_header")
        self.merger_member_header = QtWidgets.QLabel(self.merger_tab)
        self.merger_member_header.setGeometry(QtCore.QRect(1030, 120, 71, 20))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.merger_member_header.setFont(font)
        self.merger_member_header.setObjectName("merger_member_header")
        self.MainWindow.setCentralWidget(self.centralwidget)
        self.merger_menubar = QtWidgets.QMenuBar(self.MainWindow)
        self.merger_menubar.setGeometry(QtCore.QRect(0, 0, 1280, 26))
        self.merger_menubar.setObjectName("merger_menubar")
        self.MainWindow.setMenuBar(self.merger_menubar)
        self.merger_statusbar = QtWidgets.QStatusBar(self.MainWindow)
        self.merger_statusbar.setObjectName("merger_statusbar")
        self.MainWindow.setStatusBar(self.merger_statusbar)

        # Messages
        self.messages_tab = QtWidgets.QWidget()
        self.messages_tab.setObjectName("messages_tab")

        self.m_usr_label = QtWidgets.QLabel(self.messages_tab)
        self.m_usr_label.setGeometry(QtCore.QRect(1180, 605, 500, 50))
        self.m_usr_label.setObjectName("m_usr_label")

        self.scrollArea_3 = QtWidgets.QScrollArea(self.messages_tab)
        self.scrollAreaWidgetContents_3 = QtWidgets.QWidget()
        self.scrollAreaWidgetContents_3.setGeometry(QtCore.QRect(0, 0, 1079, 600))
        self.scrollAreaWidgetContents_3.setObjectName("scrollAreaWidgetContents_3")

        self.messageEdit = QtWidgets.QTextEdit(self.messages_tab)
        self.messageEdit.setGeometry(QtCore.QRect(20, 600, 950, 50))
        self.messageEdit.setObjectName("messageEdit")

        self.messageSend = QtWidgets.QPushButton(self.messages_tab)
        self.messageSend.setGeometry(QtCore.QRect(990, 610, 150, 50))
        self.messageSend.setObjectName("messageSend")

        self.messageSend.clicked.connect(self.sendMessage)
        self.messageList = QtWidgets.QTextEdit(self.scrollAreaWidgetContents_3)
        self.messageList.setGeometry(QtCore.QRect(0, 0, 1081, 550))
        self.messageList.setObjectName("messageList")
        self.messageList.setReadOnly(True)

        self.scrollArea_3.setWidget(self.scrollAreaWidgetContents_3)
        self.scrollArea_3.setGeometry(QtCore.QRect(20, 40, 1081, 631))
        self.scrollArea_3.setWidgetResizable(True)
        self.scrollArea_3.setObjectName("scrollArea_3")

        self.mainTab.addTab(self.messages_tab, "")
        self.MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(self.MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1280, 21))
        self.menubar.setObjectName("menubar")
        self.MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(self.MainWindow)
        self.statusbar.setObjectName("statusbar")
        self.MainWindow.setStatusBar(self.statusbar)

        # Establishing Initial Settings
        self.retranslateUi()
        self.mainTab.setCurrentIndex(0)
        # self.home_votes_widget.setCurrentIndex(1)
        # self.stackedWidget_3.setCurrentIndex(0)
        QtCore.QMetaObject.connectSlotsByName(self.MainWindow)
        self.centralwidget.setCurrentIndex(0)

    def retranslateUi(self):
        _translate = QtCore.QCoreApplication.translate
        self.MainWindow.setWindowTitle(_translate("MainWindow", "ToGather"))

        # Home
        # self.commandLinkButton_3.setText(_translate("MainWindow", "Vote 1"))
        # self.commandLinkButton_4.setText(_translate("MainWindow", "Vote 2"))
        # self.home_votes_widget.setTabText(self.home_votes_widget.indexOf(self.finished_vote_tab),
        #                                   _translate("MainWindow", "Finished Votes"))
        # self.commandLinkButton.setText(_translate("MainWindow", "Vote 1"))
        # self.commandLinkButton_2.setText(_translate("MainWindow", "Vote 2"))
        # self.home_votes_widget.setTabText(self.home_votes_widget.indexOf(self.progress_votes_tab),
        #                                   _translate("MainWindow", "In-Progress Votes"))
        # self.home_upcoming_events.setHtml(_translate("MainWindow",
        #                                              "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
        #                                              "<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
        #                                              "p, li { white-space: pre-wrap; }\n"
        #                                              "</style></head><body style=\" font-family:\'MS Shell Dlg 2\'; font-size:8.25pt; font-weight:400; font-style:normal;\">\n"
        #                                              "<p align=\"center\" style=\" margin-top:0px; margin-bottom:0px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-size:16pt;\">Upcoming Events</span></p></body></html>"))
        # self.home_login.setText(_translate("MainWindow", "Log In"))
        self.home_logout.setText(_translate("MainWindow", "Log Out "))
        # self.home_new_messages.setText(_translate("MainWindow", "x New Messages"))
        self.home_image.setText(_translate("MainWindow",
                                           "<html><head/><body><p align=\"center\">ToGather </p><p align=\"center\">(logo not implemented remotely yet)</p></body></html>"))
        with importlib_resources.path(bin, "Logo.png") as p:
            path = p
        pixmap = QtGui.QPixmap(str(path))
        self.home_image.setPixmap(pixmap)
        self.home_image.setScaledContents(True)
        self.mainTab.setTabText(self.mainTab.indexOf(self.home_tab), _translate("MainWindow", "Home"))
        self.background_style.setText(_translate("MainWindow", "Style Settings"))
        self.style_button.setText(_translate("MainWindow", "Dark Mode"))
        # self.checkBox_6.setText(_translate("MainWindow", "CheckBox"))
        # self.mainTab.setTabText(self.mainTab.indexOf(self.user_settings_tab), _translate("MainWindow", "User Settings"))
        self.teal_button.setStyleSheet("background-color : teal")
        self.teal_button.setFlat(True)
        # self.pink_button.setText(_translate("MainWindow", "Pink"))
        self.pink_button.setStyleSheet("background-color : pink")
        self.pink_button.setFlat(True)
        # self.purple_button.setText(_translate("MainWindow", "Purple"))
        self.purple_button.setStyleSheet("background-color : purple")
        self.purple_button.setFlat(True)
        # self.checkBox_6.setText(_translate("MainWindow", "CheckBox"))
        # self.mainTab.setTabText(self.mainTab.indexOf(self.user_settings_tab), _translate("MainWindow", "User Settings"))
        self.red_button.setStyleSheet("background-color : red")
        self.red_button.setFlat(True)
        self.blue_button.setStyleSheet("background-color : blue")
        self.blue_button.setFlat(True)
        self.yellow_button.setStyleSheet("background-color : yellow")
        self.yellow_button.setFlat(True)
        # Events + Circles Merger
        self.mainTab.setTabText(self.mainTab.indexOf(self.merger_tab), _translate("MainWindow", "Circles"))
        self.merger_group_name.setText(_translate("MainWindow", "Group Name"))
        self.merger_schedule_button.setText(_translate("MainWindow", "Schedules"))
        self.merger_add_event_button.setText(_translate("MainWindow", "Add Event"))
        self.merger_switch_group_button.setText(_translate("MainWindow", "Switch Group"))
        self.merger_add_group_button.setText(_translate("MainWindow", "Add Group"))
        self.merger_add_member_button.setText(_translate("MainWindow", "Add Member"))
        self.merger_event_header.setText(_translate("MainWindow", "Events:"))
        self.merger_member_header.setText(_translate("MainWindow", "Members:"))

        # Messages
        self.messageSend.setText(_translate("MainWindow", "Send"))
        self.mainTab.setTabText(self.mainTab.indexOf(self.messages_tab), _translate("MainWindow", "Messages"))

    def sendMessage(self):
        if self.current_group is not None:
            g = self.current_group
            m = Message(str(len(g.messages) + 1), self.messageEdit.toPlainText(), self.current_user.name,
                        self.current_group.name)
            g.messages.append(m)
            print(len(g.messages))
            Data.add_message(m)
            Data.update_group(g)
            self.messageList.append('\n' + m.sender + ': ' + m.delivery + '\n')
            self.messageEdit.clear()

    def updateMessageList(self):
        self.messageList.clear()
        if self.current_group is not None:
            g = Data.get_groups(self.current_group.name)
            messagearray = g.messages
            for i in messagearray:
                self.messageList.append('\n' + i.sender + ': ' + i.delivery + '\n')

    def gotosplash(self):
        self.current_user = None
        self.current_group = None
        self.centralwidget.setCurrentIndex(0)

    def gotologin(self):
        self.login_page = LogIn(self)
        self.login_page.adjustSize()
        self.login_page.show()

    def gotocreate(self):
        self.groupcreate = GroupCreate(self)
        self.groupcreate.adjustSize()
        self.groupcreate.show()

    def gotoadd(self):
        self.addmember = AddMember(self)
        self.addmember.adjustSize()
        self.addmember.show()

    def removeMember(self, group, name):
        groupobj = Data.get_groups(group)
        for pair in groupobj.users:
            if pair[0] == name:
                groupobj.users.remove(pair)
        Data.update_group(groupobj)
        user = Data.get_users(name)
        user.groups.remove(group)
        Data.update_user(user)
        if name == self.current_user.name:
            user = Data.get_users(name)
            if len(user.groups) == 0:
                layout = self.merger_scrollAreaWidgetContents.layout()
                layout2 = self.merger_scrollAreaWidgetContents_2.layout()
                for i in reversed(range(layout.count())):
                    layout.itemAt(i).widget().setParent(None)
                for i in reversed(range(layout2.count())):
                    layout2.itemAt(i).widget().setParent(None)
                self.merger_group_name.setText("")
            else:
                self.update_group(Data.get_groups(user.groups[0]))
        else:
            self.update_group(groupobj)
        if len(Data.get_groups(group).users) == 0:
            for event in Data.get_groups(group).events:
                Data.delete_event(event)
                print("count")
            print(len(Data.get_groups(group).events))
            Data.delete_group(Data.get_groups(group))

    def gotoaddevent(self):
        self.newevent = NewEvent(self)
        self.newevent.adjustSize()
        self.newevent.show()

    def gotovoting(self, e, c):
        if e.status == False:
            self.voting = VotingPoll(self, e, c)
            self.voting.show()
        else:
            vote_msg = QtWidgets.QMessageBox()
            vote_msg.setIcon(QtWidgets.QMessageBox.Warning)
            vote_msg.setWindowTitle("Voting Finished")
            vote_msg.setText("The voting has already finished for this event. Results are displayed.")
            vote_msg.exec_()
            self.voting = VotingPoll(self, e, c)
            self.voting.results(e, c)

    def gotooptions(self, e):
        if e.status == False:
            self.customoptions = OptionSettings(self, e)
            self.customoptions.show()
        else:
            vote_msg = QtWidgets.QMessageBox()
            vote_msg.setIcon(QtWidgets.QMessageBox.Warning)
            vote_msg.setWindowTitle("Voting Finished")
            vote_msg.setText("The voting has already finished for this event. Options can not be changed.")
            vote_msg.exec_()

    def gotoyourcircles(self):
        self.yourcircles = YourCircles(self)
        self.yourcircles.adjustSize()
        self.yourcircles.show()

    def gotoschedules(self):
        self.schedules = Schedules(parent=self)
        # self.schedules.adjustSize()
        self.schedules.show()

    def update_group(self, new_group):
        self.current_group = new_group
        layout = self.merger_scrollAreaWidgetContents.layout()
        layout2 = self.merger_scrollAreaWidgetContents_2.layout()
        for i in reversed(range(layout.count())):
            layout.itemAt(i).widget().setParent(None)
        for i in reversed(range(layout2.count())):
            layout2.itemAt(i).widget().setParent(None)
        self.merger_group_name.setText(new_group.name)
        for event in Data.get_events(None, new_group.name):
            app = QtWidgets.QFrame()
            frames = bin.eventwidget.Ui_Form()
            frames.setupUi(app)
            frames.name_label.setText("Name: " + event.name)
            frames.date_label.setText("Date: " + event.description)
            frames.vote_go_button.clicked.connect(
                lambda checked, a=event, b=new_group.name: self.gotovoting(a, b))
            frames.op_go_button.clicked.connect(lambda checked, a=event: self.gotooptions(a))
            layout.addWidget(app)
        for member in Data.get_groups(self.current_group.name).users:
            with importlib_resources.path(bin, "member.ui") as p:
                path = p
            self.memwidget = loadUi(str(path))
            self.memwidget.removeButton.clicked.connect(
                partial(self.removeMember, new_group.name, member[0]))
            self.memwidget.memberName.setText(member[0])
            self.merger_scrollAreaWidgetContents_2.layout().addWidget(self.memwidget)
        self.updateMessageList()
        # print(len(self.groups))

    def add_member_group(self, new_user, the_group):
        new_name = new_user  # need to find a way to get
        # print(new_user)
        # print(the_group)

        if new_name != "":
            self.label_16.setText(new_name)

    def update_event(self, event):
        self.event_title.setText(event.name)
        self.event_date.setText(event.description)  # time equals place??
        self.event_place.setText(event.options)

    def change_color(self, parent, color, mode):
        app = QApplication.instance()
        if mode == 1:
            if self.style_button.text() == "Light Mode":
                apply_stylesheet(app, theme='dark_' + color + '.xml', invert_secondary=False)
                with importlib_resources.path(bin, "Dark_Logo.png") as p:
                    path = p
                pixmap = QtGui.QPixmap(str(path))
                self.splashWindow.splash_image.setPixmap(pixmap)
                self.home_image.setPixmap(pixmap)
                self.home_image.setScaledContents(True)
                self.current_color = color

            else:
                apply_stylesheet(app, theme='light_' + color + '.xml', invert_secondary=True)
                with importlib_resources.path(bin, "Logo.png") as p:
                    path = p
                pixmap = QtGui.QPixmap(str(path))
                self.splashWindow.splash_image.setPixmap(pixmap)
                self.home_image.setPixmap(pixmap)
                self.home_image.setScaledContents(True)
                self.current_color = color
        else:
            if self.style_button.text() == "Dark Mode":
                apply_stylesheet(app, theme='dark_' + self.current_color + '.xml', invert_secondary=False)
                with importlib_resources.path(bin, "Dark_Logo.png") as p:
                    path = p
                pixmap = QtGui.QPixmap(str(path))
                self.splashWindow.splash_image.setPixmap(pixmap)
                self.home_image.setPixmap(pixmap)
                self.home_image.setScaledContents(True)
                self.style_button.setText("Light Mode")
            else:
                apply_stylesheet(app, theme='light_' + self.current_color + '.xml', invert_secondary=True)
                with importlib_resources.path(bin, "Logo.png") as p:
                    path = p
                pixmap = QtGui.QPixmap(str(path))
                self.splashWindow.splash_image.setPixmap(pixmap)
                self.home_image.setPixmap(pixmap)
                self.home_image.setScaledContents(True)
                self.style_button.setText("Dark Mode")


class UpdateMonitor(QtCore.QObject):
    update_signal = QtCore.pyqtSignal()

    @QtCore.pyqtSlot()
    def monitor_updates(self):
        while True:
            time.sleep(1)
            if Data.update_UI:
                self.update_signal.emit()
                Data.update_UI = False  # Reset Data.update_UI


class SplashScreen(QMainWindow):
    def __init__(self, parent, window):
        super().__init__()
        self.parent = parent
        self.window = window
        self.setWindowTitle("ToGather")
        self.setObjectName("SplashWindow")

        _translate = QtCore.QCoreApplication.translate
        self.setWindowTitle(_translate("SplashWindow", "Welcome!"))

        self.splash_image = QtWidgets.QLabel(self)
        self.splash_image.setGeometry(QtCore.QRect(300, 0, 641, 312))
        self.splash_image.setObjectName("splash_image")
        with importlib_resources.path(bin, "Logo.png") as p:
            path = p
        pixmap = QtGui.QPixmap(str(path))
        self.splash_image.setPixmap(pixmap)
        self.splash_image.setScaledContents(True)

        self.splash_login = QtWidgets.QPushButton(self)
        self.splash_login.setGeometry(QtCore.QRect(360, 300, 500, 50))
        self.splash_login.setObjectName("splash_login")
        self.splash_login.clicked.connect(self.login)
        self.splash_login.setText(_translate("MainWindow", "Log In"))

        self.splash_signup = QtWidgets.QPushButton(self)
        self.splash_signup.setGeometry(QtCore.QRect(360, 350, 500, 50))
        self.splash_signup.setObjectName("splash_signup")
        self.splash_signup.clicked.connect(self.signup)
        self.splash_signup.setText(_translate("MainWindow", "Sign Up"))

    def login(self):
        self.login_page = LogIn(self, self.window)
        self.login_page.adjustSize()
        self.login_page.show()

    def signup(self):
        self.signup_page = SignUp(self, self.window)
        self.signup_page.adjustSize()
        self.signup_page.show()


class VoteRes(QMainWindow):
    def __init__(self, parent):
        super().__init__()
        self.parent = parent
        with importlib_resources.path(bin, "voting_res.ui") as p:
            path = p
        loadUi(str(path), self)
        self.return_button.clicked.connect(self.return_voting)

        self.user_vote_scroll = QtWidgets.QScrollArea(self)
        self.user_vote_scroll.setGeometry(QtCore.QRect(771, 49, 287, 536))
        self.user_vote_scroll.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOn)
        self.user_vote_scroll.setObjectName("user_vote_scroll")
        self.user_vote_scroll.setWidgetResizable(True)
        self.vote_scroll_contents = QtWidgets.QWidget()
        self.vote_scroll_contents.setGeometry(QtCore.QRect(0, 0, 285, 534))

        self.user_vote_scroll_2 = QtWidgets.QScrollArea(self)
        self.user_vote_scroll_2.setGeometry(QtCore.QRect(479, 49, 287, 536))
        self.user_vote_scroll_2.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOn)
        self.user_vote_scroll_2.setObjectName("user_vote_scroll")
        self.user_vote_scroll_2.setWidgetResizable(True)
        self.vote_scroll_contents_2 = QtWidgets.QWidget()
        self.vote_scroll_contents_2.setGeometry(QtCore.QRect(0, 0, 285, 534))

        self.vote_grid = QtWidgets.QVBoxLayout(self.vote_scroll_contents)
        self.vote_grid.setObjectName("vote_grid")
        self.user_vote_scroll.setWidget(self.vote_scroll_contents)

        self.vote_grid_2 = QtWidgets.QVBoxLayout(self.vote_scroll_contents_2)
        self.vote_grid_2.setObjectName("vote_grid_2")
        self.user_vote_scroll_2.setWidget(self.vote_scroll_contents_2)

    def return_voting(self):
        print("Return to Voting")
        self.close()


class LogIn(QMainWindow):
    def __init__(self, parent, window):
        super().__init__()
        self.parent = parent
        self.window = window
        # with importlib_resources.path(bin, "login.ui") as p:
        #    path = p
        with importlib_resources.path(bin, "login.ui") as p:
            path = p
        loadUi(str(path), self)
        self.login_password_entry.setEchoMode(QtWidgets.QLineEdit.Password)
        self.login_acc_button.clicked.connect(self.login_acc)
        self.signup_button.clicked.connect(self.nav)

    # Method that runs when login button is pressed.
    def login_acc(self):
        # Check if username exists.
        if Data.get_users(self.login_username_entry.text()):
            # Check if password matches the password from database.
            user = Data.get_users(self.login_username_entry.text())
            if user.password == self.login_password_entry.text():
                # Update the current_user variable stored in MainWindow
                msg = QtWidgets.QMessageBox()
                msg.setIcon(QtWidgets.QMessageBox.Information)
                msg.setWindowTitle("Login Success")
                msg.setText("You have successfully logged in as " + user.name)
                msg.exec_()

                self.window.current_user = user

                # self.window.current_group = None

                _translate = QtCore.QCoreApplication.translate
                self.window.h_usr_label.setText(
                    (_translate("MainWindow", "User: " + self.window.current_user.name + "")))
            self.window.m_usr_label.setText((_translate("MainWindow", "User: " + self.window.current_user.name + "")))
            self.window.c_usr_label.setText((_translate("MainWindow", "User: " + self.window.current_user.name + "")))

            if len(Data.get_users(user.name).groups) == 0:
                layout = self.window.merger_scrollAreaWidgetContents.layout()
                layout2 = self.window.merger_scrollAreaWidgetContents_2.layout()
                for i in reversed(range(layout.count())):
                    layout.itemAt(i).widget().setParent(None)
                for i in reversed(range(layout2.count())):
                    layout2.itemAt(i).widget().setParent(None)
                self.window.merger_group_name.setText("")
                self.window.messageList.clear()
                self.window.messageEdit.clear()
            else:
                self.window.update_group(Data.get_groups(user.groups[0]))
            # TODO: Create a method to update other UI objects that use current user.
            # self.parent.user_settings_name.setText(self.parent.current_user.name)
            self.window.centralwidget.setCurrentIndex(1)
            self.close()
        else:
            err_msg = QtWidgets.QMessageBox()
            err_msg.setIcon(QtWidgets.QMessageBox.Warning)
            err_msg.setWindowTitle("Login Failed")
            err_msg.setText("Incorrect password. Please try again.")
            err_msg.exec_()


# valid = [x for x, y in enumerate(self.parent.usersarr) if y[0] == self.login_username_entry.text() and y[1] == self.login_password_entry.text()]
# if valid:
#    print("Logged In")
#    self.close()
# else:
#    print("Invalid login!")

    def nav(self):
        print("To Signup!")
        self.signup_window = SignUp(self, self.window)
        self.setWindowTitle("Sign Up")
        self.signup_window.adjustSize()
        self.signup_window.show()
        self.close()


class SignUp(QMainWindow):
    def __init__(self, parent, window):
        super().__init__()
        self.parent = parent
        self.window = window
        # with importlib_resources.path(bin, "signup.ui") as p:
        #    path = p
        with importlib_resources.path(bin, "signup.ui") as p:
            path = p
        loadUi((str(path)), self)
        self.signup_password_entry.setEchoMode(QtWidgets.QLineEdit.Password)
        self.signup_c_password_entry.setEchoMode(QtWidgets.QLineEdit.Password)
        self.signup_submit_button.clicked.connect(self.submit)

    def submit(self):
        if (
                self.signup_username_entry.text() == "" or self.signup_password_entry.text() == "" or self.signup_c_password_entry.text() == ""):
            err_msg = QtWidgets.QMessageBox()
            err_msg.setIcon(QtWidgets.QMessageBox.Warning)
            err_msg.setWindowTitle("Signup Failed")
            err_msg.setText("Please enter info into all empty fields.")
            err_msg.exec_()
        elif self.signup_password_entry.text() == self.signup_c_password_entry.text():

            # Add user to local array for testing.
            # userpair = (self.signup_username_entry.text(), self.signup_password_entry.text())
            # self.parent.usersarr.append(userpair)

            # Make sure username doesn't already exist.
            valid = True
            for user in Data.get_users():
                if user.name.lower() == self.signup_username_entry.text().lower():
                    valid = False
            if valid:
                # Add new user to database.
                user = User(name=self.signup_username_entry.text(), password=self.signup_password_entry.text())
                Data.add_user(user)

                # Update the current_user variable stored in MainWindow
                self.window.current_user = user
                self.window.current_group = None
                self.window.messageList.clear()
                self.window.messageEdit.clear()
                _translate = QtCore.QCoreApplication.translate
                self.window.h_usr_label.setText(
                    (_translate("MainWindow", "User: " + self.window.current_user.name + "")))
                self.window.m_usr_label.setText(
                    (_translate("MainWindow", "User: " + self.window.current_user.name + "")))
                self.window.c_usr_label.setText(
                    (_translate("MainWindow", "User: " + self.window.current_user.name + "")))
                if Data.get_users(user.name) is not None:
                    layout = self.window.merger_scrollAreaWidgetContents.layout()
                    layout2 = self.window.merger_scrollAreaWidgetContents_2.layout()
                    for i in reversed(range(layout.count())):
                        layout.itemAt(i).widget().setParent(None)
                    for i in reversed(range(layout2.count())):
                        layout2.itemAt(i).widget().setParent(None)
                    self.window.merger_group_name.setText("")
                # TODO: Create a method to update all UI objects that use current user.
                # Update UI elements that relate to current user.
                # self.parent.parent.user_settings_name.setText(self.parent.current_user.name)

                err_msg = QtWidgets.QMessageBox()
                err_msg.setIcon(QtWidgets.QMessageBox.Warning)
                err_msg.setWindowTitle("Signup Success")
                err_msg.setText("Your new account has been successfully created. Welcome " + user.name)
                err_msg.exec_()

                self.window.centralwidget.setCurrentIndex(1)
                self.close()
            else:
                err_msg = QtWidgets.QMessageBox()
                err_msg.setIcon(QtWidgets.QMessageBox.Warning)
                err_msg.setWindowTitle("Signup Failed")
                err_msg.setText("Username already exists. Please try a new username.")
                err_msg.exec_()
        else:
            err_msg = QtWidgets.QMessageBox()
            err_msg.setIcon(QtWidgets.QMessageBox.Warning)
            err_msg.setWindowTitle("Signup Failed")
            err_msg.setText("Passwords do not match. Please retype the passwords.")
            err_msg.exec_()

# Called by Add Group button
class GroupCreate(QMainWindow):
    def __init__(self, parent):
        super().__init__()
        self.parent = parent
        # with importlib_resources.path(bin, "popup.ui") as p:
        #    path = p
        with importlib_resources.path(bin, "popup.ui") as p:
            path = p
        loadUi(str(path), self)
        self.submission_button.clicked.connect(self.submit)

    def submit(self):
        invalid = True
        for group in Data.get_groups():
            if group.name.lower() == self.group_name_entry.text().lower():
                invalid = False
        if not invalid:
            err_msg = QtWidgets.QMessageBox()
            err_msg.setIcon(QtWidgets.QMessageBox.Warning)
            err_msg.setWindowTitle("Group Not Created")
            err_msg.setText("Group already exists. Please choose a different name.")
            err_msg.exec_()
        else:
            print("Submitted")
            f = QtWidgets.QFrame()
            frames = bin.groupwidget.Ui_Form()
            frames.setupUi(f)
            frames.group_name_label.setText("Circle Name: " + self.group_name_entry.text())
            schedulelist = [[], [], [], [], [], [], []]
            memberarr = [(self.parent.current_user.name, schedulelist)]
            grouptuple = Group(name=self.group_name_entry.text(), users=memberarr)
            self.parent.circlearr.append(grouptuple)
            Data.add_group(grouptuple)
            user = Data.get_users(self.parent.current_user.name)
            user.groups.append(grouptuple.name)
            Data.update_user(user)
            # bellow is not needed but kept incase for styling
            # grouplist = user.groups
            # grouplist.append(grouptuple)
            self.parent.current_user = Data.get_users(user.name)
            # self.parent.merger_scrollAreaWidgetContents.layout().addWidget(f)
            self.parent.update_group(grouptuple)
            self.close()


class VotingPoll(QMainWindow):
    def __init__(self, parent, e, c):
        super().__init__(parent)
        self.parent = parent
        self.cbs = []
        self.user = self.parent.current_user.name
        self.counter = 0

        with importlib_resources.path(bin, "voting.ui") as p:
            path = p
        loadUi(str(path), self)
        self.vote_scroll = QtWidgets.QScrollArea(self)
        self.vote_scroll.setGeometry(QtCore.QRect(150, 70, 800, 250))
        self.vote_scroll.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOn)
        self.vote_scroll.setObjectName("vote_scroll")
        self.vote_scroll.setWidgetResizable(True)
        self.vote_scroll_contents = QtWidgets.QWidget()
        self.vote_scroll_contents.setGeometry(QtCore.QRect(0, 0, 300, 300))
        self.vote_grid = QtWidgets.QVBoxLayout(self.vote_scroll_contents)
        self.vote_grid.setObjectName("vote_grid")
        self.vote_scroll.setWidget(self.vote_scroll_contents)
        self.submitVote.clicked.connect(lambda checked, a=e, b=c: self.submit(a, b))

        count = 1
        for x in e.options:
            self.f = QtWidgets.QFrame(self)
            self.f.setGeometry(QtCore.QRect(100, 100, 721, 61))
            self.f.setFrameShape(QtWidgets.QFrame.StyledPanel)
            self.f.setFrameShadow(QtWidgets.QFrame.Raised)
            self.f.setObjectName("f" + str(count))

            self.frames = bin.votingwidget.Ui_Form()
            self.frames.setupUi(self.f)

            content = "Name: " + x.name + "\nActivity: " + x.activity + "\nLocation: " + x.location + "\nTime: " + str(
                x.time) + "\n"
            self.frames.option_info.setText(content)

            self.vote_choices = self.optionComboBox(self.f, e, x)
            self.cbs.append(self.vote_choices)
            self.vote_scroll_contents.layout().addWidget(self.f)

            x.votes[self.user] = 1

            count += 1

    def optionComboBox(self, f, e, x):

        cb = QtWidgets.QComboBox(f)
        cb.setGeometry(650, 5, 120, 60)
        for i in range(1, len(e.options) + 1):
            cb.addItem("Choice {0}".format(i))
        cb.currentIndexChanged.connect(lambda checked, a=x, b=cb: self.vote(a, b))

        return cb

    def vote(self, x, cb):
        x.votes[self.user] = cb.currentIndex() + 1

    def submit(self, e, c):
        submit_msg = QtWidgets.QMessageBox()
        submit_msg.setIcon(QtWidgets.QMessageBox.Information)

        success = True

        if (len(e.options) == 0):
            submit_msg.setWindowTitle("Submit Failed")
            submit_msg.setText("No options have been added to the event. Your vote has not been submitted.")
            submit_msg.exec_()
            success = False

        for i in range(1, len(e.options) + 1):
            dup = 0
            for x in e.options:
                if (x.votes[self.user] == i):
                    dup += 1
            if (dup > 1):
                submit_msg.setWindowTitle("Submit Failed")
                submit_msg.setText("You can only choose one rank for each option. Your vote has not been submitted.")
                submit_msg.exec_()
                success = False
                break

        if success:
            submit_msg.setWindowTitle("Submit Successful")
            submit_msg.setText("Your vote has been submitted.")
            submit_msg.exec_()

            for x in e.options:
                Data.update_option(x)
            ev = Data.get_events(e.name, c)
            ev.submitted[self.user] = True

            Data.update_event(Event(ev.name, ev.description, e.options, ev.group, ev.submitted, ev.status))

            self.loading = LoadingScreen(self.parent)
            self.loading.startAnim()
            self.close()
            self.thread = QThread()
            self.worker = LoadingWorker(c, e, self.loading)
            self.worker.moveToThread(self.thread)
            self.thread.started.connect(self.worker.run)
            self.worker.finished.connect(self.thread.quit)
            self.worker.finished.connect(self.worker.deleteLater)
            self.thread.finished.connect(self.thread.deleteLater)
            self.thread.start()
            self.thread.finished.connect(lambda a=e, b=c: self.results(a, b))

    def results (self, e, c):
        circle = Data.get_groups(c)
        ev = Data.get_events(e.name, circle.name)

        top = float('inf')
        averages = {}
        choices = []
        winner = ""
        set0 = QBarSet('Averages')

        for x in ev.options:
            avg = 0
            for y in x.votes.values():
                avg += y
                print(y)
                print(x.votes.values)
            avg = avg / len(circle.users)
            averages[x.name] = avg
            choices.append(x.name)
        for x in averages:
            if (averages[x] < top):
                top = averages[x]
                winner = x
            set0.append(averages[x])

        o = Data.get_options(winner)
        if(ev.status == False):
            o.chosen = True
            ev.status = True
            Data.update_option(o)
            Data.update_event(ev)

        res = QBarSeries()
        res.append(set0)
        graph = QChart()
        graph.addSeries(res)
        graph.setTitle('Voting Results')
        graph.setAnimationOptions(QChart.SeriesAnimations)
        x_axis = QBarCategoryAxis()
        x_axis.append(choices)
        y_axis = QValueAxis()
        graph.addAxis(x_axis, Qt.AlignBottom)
        graph.addAxis(y_axis, Qt.AlignLeft)
        res.attachAxis(y_axis)
        graph.legend().setVisible(True)
        graph.legend().setAlignment(Qt.AlignBottom)

        self.winner_msg = VoteRes(self)
        self.winner_msg.setWindowTitle("Voting Results")
        self.winner_msg.chart_view.setChart(graph)
        self.winner_msg.winner_info.setText(
            "Name: " + o.name + "  Activity: " + o.activity + "  Location: " + o.location + "  Time: " + str(
                o.time) + "")
        for x, y in sorted(averages.items()):
            with importlib_resources.path(bin, "voting_res_list.ui") as p:
                path = p
            self.mem = loadUi(str(path))
            self.mem.vote_res_label.setText("Average Rank: " + str(y) + " | Option: " + x + "")
        self.winner_msg.vote_scroll_contents_2.layout().addWidget(self.mem)
        for x in circle.users:
            with importlib_resources.path(bin, "voting_res_list.ui") as p:
                path = p
            self.mem = loadUi(str(path))
            self.mem.vote_res_label.setText(x[0])
            self.winner_msg.vote_scroll_contents.layout().addWidget(self.mem)
        self.winner_msg.show()


class LoadingWorker(QObject):
    finished = pyqtSignal()

    def __init__(self, c, e, l):
        super().__init__()
        self.e = e
        self.c = c
        self.loading = l

    def run(self):
        circle = Data.get_groups(self.c).users
        ev = Data.get_events(self.e.name, self.c).submitted
        while (len(ev) != len(circle)):
            ev = Data.get_events(self.e.name, self.c).submitted
        self.loading.stopAnim()
        self.finished.emit()


class LoadingScreen(QMainWindow):
    def __init__(self, parent):
        super().__init__()
        self.parent = parent
        self.setFixedSize(200, 200)
        self.anim_label = QtWidgets.QLabel(self)
        self.anim_label.setGeometry(QtCore.QRect(0, 0, 200, 200))
        with importlib_resources.path(bin, "loading.gif") as p:
            path = p
        self.movie = QMovie(str(path))
        self.anim_label.setMovie(self.movie)

    def startAnim(self):
        self.movie.start()
        self.show()

    def stopAnim(self):
        self.movie.stop()
        self.close()


class OptionSettings(QMainWindow):
    def __init__(self, parent, e):
        super().__init__(parent)
        self.parent = parent
        with importlib_resources.path(bin, "options.ui") as p:
            path = p
        loadUi(str(path), self)
        self.submit_option.clicked.connect(lambda checked, a=e: self.submit(e))
        self.remove_option.clicked.connect(lambda checked, a=e: self.remove(e))

    def submit(self, e):
        self.timeEdit.time().toString("h:m:s ap")
        o = Option(self.options_name.text(), self.options_activity.text(), self.options_location.text(),
                   self.timeEdit.time().toString("h:m:s ap"), False, {})
        e.options.append(o)
        Data.update_event(e)
        Data.add_option(o)
        # f = QtWidgets.QFrame()
        # frames = votingwidget.Ui_Form()
        # frames.setupUi(f)
        # f.setObjectName("option_frame_"+self.options_name.text())
        # choices = self.voting_window.optionComboBox(f, o)
        # for i in self.voting_window.cbs:
        # i.addItem("Choice {0}".format(len(self.voting_window.cbs)+1))
        # self.voting_window.cbs.append(choices)
        # content = "Name: " + self.options_name.text() + "\nActivity: " + self.options_activity.text() + "\nLocation: " + self.options_location.text() + "\nTime: " + str(None) + "\n"
        # frames.option_info.setText(content)
        # self.voting_window.vote_scroll_contents.layout().addWidget(f)

        self.close()

    def remove(self, e):
        count = 0
        found = False
        for i in e.options:
            if i.name == self.options_del_name.text():
                e.options.remove(i)
                Data.update_event(e)
                Data.delete_option(i)
                found = True
                msg = QtWidgets.QMessageBox()
                msg.setIcon(QtWidgets.QMessageBox.Information)
                msg.setWindowTitle("Optioned Removed")
                msg.setText("Option successfully removed.")
                msg.exec_()
                break
            count += 1
        if found == False:
            err_msg = QtWidgets.QMessageBox()
            err_msg.setIcon(QtWidgets.QMessageBox.Warning)
            err_msg.setWindowTitle("Option Removal Failed")
            err_msg.setText("Option does not exist for the event. Please retype the option.")
            err_msg.exec_()
        self.close()


class AddMember(QMainWindow):
    def __init__(self, parent):
        super().__init__()
        self.parent = parent
        # with importlib_resources.path(bin, "newmember.ui") as p:
        #    path = p
        with importlib_resources.path(bin, "newmember.ui") as p:
            path = p
        loadUi(str(path), self)
        self.submission_button.clicked.connect(self.submit)

    def submit(self):
        if not Data.get_users(self.name_entry.text()):
            err_msg = QtWidgets.QMessageBox()
            err_msg.setIcon(QtWidgets.QMessageBox.Warning)
            err_msg.setWindowTitle("Member Not Added")
            err_msg.setText("Username does not exist. Please retype the username.")
            err_msg.exec_()
        else:

            # ui.add_member_group(new_user, str(self.group_name_entry.text()))
            # Data.add_user(User(new_user))
            if len(Data.get_groups()) != 0:
                # groupindex = [x[0] for x in self.parent.circlearr].index(self.group_name_entry.text())
                with importlib_resources.path(bin, "member.ui") as p:
                    path = p
                self.memwidget = loadUi(str(path))
                valid = True
                currentgroup = Data.get_groups(self.parent.current_group.name)
                userarray = currentgroup.users
                for user in userarray:
                    if user[0] == self.name_entry.text():
                        err_msg = QtWidgets.QMessageBox()
                        err_msg.setIcon(QtWidgets.QMessageBox.Warning)
                        err_msg.setWindowTitle("Member Not Added")
                        err_msg.setText("User is already in your circle.")
                        err_msg.exec_()
                        valid = False
                if valid:
                    member = Data.get_users(self.name_entry.text())
                    member.groups.append(currentgroup.name)

                    Data.update_user(member)

                    schedulelist = [[], [], [], [], [], [], []]
                    userarray.append((self.name_entry.text(), schedulelist))
                    currentgroup.users = userarray
                    Data.update_group(currentgroup)
                    self.memwidget.removeButton.clicked.connect(
                        lambda: self.parent.removeMember(currentgroup.name, self.name_entry.text()))
                    self.memwidget.memberName.setText(self.name_entry.text())
                    self.parent.merger_scrollAreaWidgetContents_2.layout().addWidget(self.memwidget)
                    print("Added New Member")
            else:
                print("No current circles!")
                err_msg = QtWidgets.QMessageBox()
                err_msg.setIcon(QtWidgets.QMessageBox.Warning)
                err_msg.setWindowTitle("Member Not Added")
                err_msg.setText("You do not have any current circles. Please create or join a circle.")
                err_msg.exec_()
        self.close()


class NewEvent(QMainWindow):
    def __init__(self, parent):
        super().__init__()
        self.parent = parent
        # with importlib_resources.path(bin, "newevent.ui") as p:
        #   path = p
        with importlib_resources.path(bin, "newevent.ui") as p:
            path = p
        loadUi(str(path), self)
        self.dateEdit.setDate(QtCore.QDate.currentDate())
        self.submission_button.clicked.connect(self.submit)

    def submit(self):
        if len(Data.get_groups()) != 0:
            with importlib_resources.path(bin, "member.ui") as p:
                path = p
            self.memwidget = loadUi(str(path))
            valid = True
            currentgroup = self.parent.current_group
            group = Data.get_groups(currentgroup.name)
            eventarray = group.events
            for event in eventarray:
                if event.name == self.name_entry.text():
                    err_msg = QtWidgets.QMessageBox()
                    err_msg.setIcon(QtWidgets.QMessageBox.Warning)
                    err_msg.setWindowTitle("Event Not Added")
                    err_msg.setText("Event already exists in your group. Please type a new event name")
                    err_msg.exec_()
                    valid = False
            if valid:
                new_event = Event(str(self.name_entry.text()), str(self.dateEdit.text()), [], currentgroup.name, {})
                Data.add_event(new_event)
                print(Data.get_events(new_event.name, new_event.group))

                app = QtWidgets.QFrame()
                frames = bin.eventwidget.Ui_Form()
                frames.setupUi(app)
                frames.name_label.setText("Name: " + self.name_entry.text())
                frames.date_label.setText("Date: " + self.dateEdit.text())
                frames.vote_go_button.clicked.connect(
                    lambda checked, a=new_event, b=currentgroup: self.parent.gotovoting(a, b))
                frames.op_go_button.clicked.connect(lambda checked, a=new_event: self.parent.gotooptions(a))
                # self.parent.scrollAreaWidgetContents.layout().addWidget(app)
                self.parent.merger_scrollAreaWidgetContents.layout().addWidget(
                    app)  # adds to merged events and not events pg

                eventarray.append(new_event)
                group.events = eventarray
                Data.update_group(group)
                print("Added New Event")
                print(Data.get_groups(group.name).events)


        else:
            print("No current circles!")
            err_msg = QtWidgets.QMessageBox()
            err_msg.setIcon(QtWidgets.QMessageBox.Warning)
            err_msg.setWindowTitle("Event Not Added")
            err_msg.setText("You do not have any current circles. Please create or join a circle.")
            err_msg.exec_()

        self.close()


class YourCircles(QMainWindow):
    def __init__(self, parent):
        super().__init__(parent)
        self.parent = parent
        with importlib_resources.path(bin, "yourcircles.ui") as p:
            path = p
        loadUi(str(path), self)
        if self.parent.current_user is not None:
            if Data.get_users(self.parent.current_user.name) is not None:
                if Data.get_users(self.parent.current_user.name).groups is not None:
                    for groups in Data.get_users(self.parent.current_user.name).groups:
                        self.groupbutton = QtWidgets.QPushButton()
                        self.groupbutton.setText(groups)
                        font = QtGui.QFont()
                        font.setPointSize(18)
                        self.groupbutton.setFont(font)
                        self.groupbutton.clicked.connect(partial(self.updateGroup, Data.get_groups(groups)))
                        self.circlesDisplay.layout().addWidget(self.groupbutton)

    def updateGroup(self, i):
        self.parent.update_group(i)
        self.close()


class Schedules(QMainWindow):
    def __init__(self, parent):
        super(Schedules, self).__init__(parent)
        self.parent = parent
        with importlib_resources.path(bin, "schedule2.ui") as p:
            path = p
        loadUi(str(path), self)
        self.sundayPush.clicked.connect(lambda: self.gotoavailability(0, self.sundayScroll))
        self.mondayPush.clicked.connect(lambda: self.gotoavailability(1, self.mondayScroll))
        self.tuesdayPush.clicked.connect(lambda: self.gotoavailability(2, self.tuesdayScroll))
        self.wednesdayPush.clicked.connect(lambda: self.gotoavailability(3, self.wednesdayScroll))
        self.thursdayPush.clicked.connect(lambda: self.gotoavailability(4, self.thursdayScroll))
        self.fridayPush.clicked.connect(lambda: self.gotoavailability(5, self.fridayScroll))
        self.saturdayPush.clicked.connect(lambda: self.gotoavailability(6, self.saturdayScroll))
        self.update_schedule()

    def gotoavailability(self, index, scrollarea):
        self.index = index
        self.scrollarea = scrollarea
        self.availability = Availability(parent=self)
        self.availability.show()

    def update_schedule(self):
        layout = self.sundayScroll.layout()
        layout2 = self.mondayScroll.layout()
        layout3 = self.tuesdayScroll.layout()
        layout4 = self.wednesdayScroll.layout()
        layout5 = self.thursdayScroll.layout()
        layout6 = self.fridayScroll.layout()
        layout7 = self.saturdayScroll.layout()
        layout8 = self.sundayJoint.layout()
        layout9 = self.mondayJoint.layout()
        layout10 = self.tuesdayJoint.layout()
        layout11 = self.wednesdayJoint.layout()
        layout12 = self.thursdayJoint.layout()
        layout13 = self.fridayJoint.layout()
        layout14 = self.saturdayJoint.layout()
        layoutlist = [layout, layout2, layout3, layout4, layout5, layout6, layout7, layout8, layout9, layout10,
                      layout11, layout12, layout13, layout14]
        for i in layoutlist:
            for j in reversed(range(i.count())):
                i.itemAt(j).widget().setParent(None)
        group = Data.get_groups(self.parent.current_group.name)
        self.label.setText("Availability for " + group.name)
        for tuple in group.users:
            if tuple[0] == self.parent.current_user.name:
                index = group.users.index(tuple)
        i = 0
        for day in group.users[index][1]:
            for interval in day:
                with importlib_resources.path(bin, "interval.ui") as p:
                    path = p
                self.interval = loadUi(str(path))
                self.interval.startTime.setText(interval[0])
                self.interval.endTime.setText(interval[1])
                self.interval.removePush.clicked.connect(partial(self.removeinterval, i, interval[0], interval[1]))
                if i == 0:
                    self.sundayScroll.layout().addWidget(self.interval)
                elif i == 1:
                    self.mondayScroll.layout().addWidget(self.interval)
                elif i == 2:
                    self.tuesdayScroll.layout().addWidget(self.interval)
                elif i == 3:
                    self.wednesdayScroll.layout().addWidget(self.interval)
                elif i == 4:
                    self.thursdayScroll.layout().addWidget(self.interval)
                elif i == 5:
                    self.fridayScroll.layout().addWidget(self.interval)
                elif i == 6:
                    self.saturdayScroll.layout().addWidget(self.interval)
            i += 1
        jointschedule = gensched.driver(group.users)
        if len(group.users) != 1:
            for i in range(7):
                with importlib_resources.path(bin, "intervalj.ui") as p:
                    path = p
                self.intervalj = loadUi(str(path))
                if jointschedule[i][0] == -1:
                    self.intervalj.timeInput.setText("No overlapping \navailabilities for this day!")
                else:
                    self.intervalj.timeInput.setText(str(jointschedule[i][0]) + " - " + str(jointschedule[i][1]))
                if i == 0:
                    self.sundayJoint.layout().addWidget(self.intervalj)
                elif i == 1:
                    self.mondayJoint.layout().addWidget(self.intervalj)
                elif i == 2:
                    self.tuesdayJoint.layout().addWidget(self.intervalj)
                elif i == 3:
                    self.wednesdayJoint.layout().addWidget(self.intervalj)
                elif i == 4:
                    self.thursdayJoint.layout().addWidget(self.intervalj)
                elif i == 5:
                    self.fridayJoint.layout().addWidget(self.intervalj)
                elif i == 6:
                    self.saturdayJoint.layout().addWidget(self.intervalj)

    def removeinterval(self, i, start, end):
        print("i is " + str(i) + "\nstart is " + start + "\nend is " + end)
        group = Data.get_groups(self.parent.current_group.name)
        for tuple in group.users:
            if tuple[0] == self.parent.current_user.name:
                index = group.users.index(tuple)
                print("index is " + str(index))
        print("length of the array of intervals is " + str(len(group.users[index][1][int(i)])))
        for interval in group.users[index][1][int(i)]:
            if interval[0] == start and interval[1] == end:
                print("got em")
                group.users[index][1][i].remove(interval)
                print("length of the array of intervals is now" + str(len(group.users[index][1][int(i)])))
            else:
                print("no dice")
        Data.update_group(group)
        self.update_schedule()


class Availability(QMainWindow):
    def __init__(self, parent):
        super(Availability, self).__init__(parent)
        self.parent = parent
        with importlib_resources.path(bin, "availability.ui") as p:
            path = p
        loadUi(str(path), self)
        self.timeEdit.setDisplayFormat("hh:mm AP")
        self.timeEdit_2.setDisplayFormat("hh:mm AP")

        def newstepBy(steps):
            if self.timeEdit.currentSection() == QtWidgets.QDateTimeEdit.MinuteSection:
                if steps == 1:
                    self.timeEdit.setTime(self.timeEdit.time().addSecs(900))
                elif steps == -1:
                    self.timeEdit.setTime(self.timeEdit.time().addSecs(-900))
            elif self.timeEdit.currentSection() == QtWidgets.QDateTimeEdit.HourSection:
                if steps == 1:
                    self.timeEdit.setTime(self.timeEdit.time().addSecs(3600))
                elif steps == -1:
                    self.timeEdit.setTime(self.timeEdit.time().addSecs(-3600))
            else:
                if steps == 1:
                    self.timeEdit.setTime(self.timeEdit.time().addSecs(43200))
                elif steps == -1:
                    self.timeEdit.setTime(self.timeEdit.time().addSecs(-43200))

        def newstepBy_2(steps):
            if self.timeEdit_2.currentSection() == QtWidgets.QDateTimeEdit.MinuteSection:
                if steps == 1:
                    self.timeEdit_2.setTime(self.timeEdit_2.time().addSecs(900))
                elif steps == -1:
                    self.timeEdit_2.setTime(self.timeEdit_2.time().addSecs(-900))
            elif self.timeEdit_2.currentSection() == QtWidgets.QDateTimeEdit.HourSection:
                if steps == 1:
                    self.timeEdit_2.setTime(self.timeEdit_2.time().addSecs(3600))
                elif steps == -1:
                    self.timeEdit_2.setTime(self.timeEdit_2.time().addSecs(-3600))
            else:
                if steps == 1:
                    self.timeEdit_2.setTime(self.timeEdit_2.time().addSecs(43200))
                elif steps == -1:
                    self.timeEdit_2.setTime(self.timeEdit_2.time().addSecs(-43200))

        self.timeEdit.stepBy = newstepBy
        self.timeEdit_2.stepBy = newstepBy_2
        self.addPush.clicked.connect(self.submit)

    def submit(self):
        if self.timeEdit.time() >= self.timeEdit_2.time() and self.timeEdit_2.time().toString("h:mm AP") != "12:00 AM":
            err_msg = QtWidgets.QMessageBox()
            err_msg.setIcon(QtWidgets.QMessageBox.Warning)
            err_msg.setWindowTitle("Invalid Interval")
            err_msg.setText("The time interval you entered is not valid. Please try again.")
            err_msg.exec_()
        else:
            starttime = self.timeEdit.time().toString("h:mm AP")
            endtime = self.timeEdit_2.time().toString("h:mm AP")
            group = Data.get_groups(self.parent.parent.current_group.name)
            for tuple in group.users:
                if tuple[0] == self.parent.parent.current_user.name:
                    userelement = group.users.index(tuple)
            overlap = False
            for interval in group.users[userelement][1][self.parent.index]:
                intervalfirst = datetime.datetime.strptime(interval[0], "%I:%M %p")
                intervalsecond = datetime.datetime.strptime(interval[1], "%I:%M %p")
                newstart = datetime.datetime.strptime(starttime, "%I:%M %p")
                newend = datetime.datetime.strptime(endtime, "%I:%M %p")
                if intervalfirst <= newstart < intervalsecond:
                    if newend <= intervalsecond and endtime != "12:00 AM":
                        overlap = True
                        self.close()
                    else:
                        overlap = True
                        newinterval = (interval[0], endtime)
                        group.users[userelement][1][self.parent.index].remove(interval)
                        group.users[userelement][1][self.parent.index].append(newinterval)
                        Data.update_group(group)
                        self.parent.update_schedule()
                        self.close()
                elif newstart < intervalfirst:
                    if intervalfirst < newend <= intervalsecond and endtime != "12:00 AM":
                        overlap = True
                        group.users[userelement][1][self.parent.index].remove(interval)
                        newinterval = (starttime, interval[1])
                        group.users[userelement][1][self.parent.index].append(newinterval)
                        Data.update_group(group)
                        self.parent.update_schedule()
                        self.close()
                    else:
                        overlap = True
                        group.users[userelement][1][self.parent.index].remove(interval)
                        newinterval = (starttime, endtime)
                        group.users[userelement][1][self.parent.index].append(newinterval)
                        Data.update_group(group)
                        self.parent.update_schedule()
                        self.close()
            if not overlap:
                group.users[userelement][1][self.parent.index].append((starttime, endtime))
                Data.update_group(group)
                self.parent.update_schedule()
                self.close()


# def watch():
#     DIRECTORY_TO_WATCH = "../"
#     observer = Observer()
#     event_handler = Handler()
#     observer.schedule(event_handler, DIRECTORY_TO_WATCH, recursive=True)
#     observer.start()
#
#     try:
#         while True:
#             time.sleep(0)
#     except:
#         observer.stop()
#         print("Error")
#
#     observer.join()
#
#
# class Handler(FileSystemEventHandler):
#
#     @staticmethod
#     def on_any_event(event):
#         if event.event_type == 'modified':
#             print("yay")


if __name__ == "__main__":
    main()
