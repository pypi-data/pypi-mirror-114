from datetime import datetime, timezone

from liquid_orm.orm import mutator
from proper.auth import Auth

from [[ app_name ]].config import config


__all__ = ["Authenticable"]

auth = Auth(
    hash_name=config.auth.hash_name,
    rounds=config.auth.get("rounds"),
    password_minlen=config.auth.password_minlen,
    password_maxlen=config.auth.password_maxlen,
)


class Authenticable:
    SESSION_KEY = "_user_token"
    REDIRECT_KEY = "_redirect"
    CLEAR_SESSION_ON_SIGN_OUT = True

    @classmethod
    def _boot(cls):
        def login(self, value):
            value = self.normalize_login(value)
            self.set_raw_attribute("login", value)

        def password(self, value):
            value = auth.hash_password(value) if value else ""
            self.set_raw_attribute("password", value)

        cls.login = mutator(login)
        cls.password = mutator(password)

        super()._boot()

    @classmethod
    def normalize_login(cls, value):
        return (value or "").lower()

    @classmethod
    def by_id(cls, user_id):
        """Modify this code or overwrite in the User class to to include whatever
        scope restriction you need to add to this query.
        """
        return cls.find(user_id)

    @classmethod
    def by_login(cls, login):
        """Modify this code or overwrite in the User class to to include whatever
        scope restriction you need to add to this query.
        """
        login = cls.normalize_login(login)
        return cls.where("login", "=", login).first()

    @classmethod
    def authenticate(cls, login, password, *, update_hash=True):
        login = cls.normalize_login(login)
        return auth.authenticate(cls, login, password, update_hash=update_hash)

    @classmethod
    def authenticate_session_token(cls, token):
        return auth.authenticate_session_token(cls, token)

    @classmethod
    def authenticate_timestamped_token(cls, token):
        return auth.authenticate_timestamped_token(cls, token, config.auth.token_life)

    def get_session_token(self):
        """Needed by auth.AuthManager.
        Makes an unique identifier for the user.
        """
        return auth.get_session_token(config.secret_key, self)

    def get_timestamped_token(self, timestamp=None):
        """Needed by auth.AuthManager.
        Makes a timestamped one-time-use token that can be used to
        identifying the user.
        """
        return auth.get_timestamped_token(config.secret_key, self, timestamp)

    def sign_in(self, req, resp):
        """Store in the session an unique token for the user, so it can stay
        logged between requests.
        """
        self.last_sign_in = datetime.now(tz=timezone.utc)
        self.save()
        assert self.id is not None
        req.user = self
        resp.session[self.SESSION_KEY] = self.get_session_token()

    def sign_out(self, req, resp):
        req.user = None
        # The session is shared so, if you have more than
        # one model/user-type signed in at the same time,
        # you don't want to do this.
        if self.CLEAR_SESSION_ON_SIGN_OUT:
            resp.session.clear()
            return

        if self.SESSION_KEY in resp.session:
            del resp.session[self.SESSION_KEY]
        if self.REDIRECT_KEY in resp.session:
            del resp.session[self.SESSION_KEY]
