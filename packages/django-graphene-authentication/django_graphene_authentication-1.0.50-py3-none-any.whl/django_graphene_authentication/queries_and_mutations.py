import abc
import functools
from calendar import timegm
from datetime import datetime, timedelta
from typing import Dict, Tuple, Callable, Union, List, Optional

import graphene
import jwt
import stringcase
from django.conf import settings
from django.contrib.auth import authenticate
from django_koldar_utils.django import auth_decorators
from django_koldar_utils.graphql.GraphQLHelper import GraphQLHelper
from graphene.types.generic import GenericScalar
from graphene.utils.thenables import maybe_thenable

from django_graphene_authentication import decorators
from django_graphene_authentication.decorators import csrf_rotation, refresh_expiration
from django_graphene_authentication.refresh_token.models import RefreshToken


class AbstractGrapheneMutationCreator(abc.ABC):
    """
    Abstract class that allows you to define a graphene authentication endpoint.

    This class generates mutation that will perform certain tasks:

     - login: a login mutation that allows you to gain access to an "authenticate" call. It's up to you what you want to
        do with such call. This means that you need to set your authentication backend correctly
     - me: a query that fetches the currently logged user.
    """

    def login_mutation_class_name(self, context) -> str:
        return f"{context}Login"

    def login_mutation_description(self, context, mutation_class_name: str) -> str:
        return f"Allows you to authenticate the user for {context}"

    def login_required_decorator(self) -> Callable[[Callable], Callable]:
        """
        Function that yields a decorator used to check if the the user invoking a graphql resolver is authenticated or not.
        Usuaally login_required
        :return:
        """
        return auth_decorators.ensure_login_required()

    def permissions_required_decorator(self) -> Callable[[Union[List[str], str]], any]:
        """
        Function that yields a decorator used to check if the the user invoking a graphql resolver has the right permissions or not.
        Usuaally has_perm
        :return:
        """
        return auth_decorators.ensure_user_has_permissions

    @abc.abstractmethod
    def get_user(self, root, info, request, *args, **kwargs):
        """
        Fetch the user from the request
        :param root: graphql root in path
        :param info: graphql info in path
        :param request: graphql request
        :param args:
        :param kwargs:
        :return:
        """
        pass

    @abc.abstractmethod
    def _login_mutation_arguments(self, context) -> Dict[str, any]:
        pass

    @abc.abstractmethod
    def _login_mutation_return_type(self, context) -> Dict[str, any]:
        """
        The list of return values generated by the login mutation
        :param context: context shared while generating the login class
        :return:
        """
        pass

    def _perform_authentication(self, mutation_instance, info, *args, **kwargs) -> any:
        """
        Perform the authentication by relayng graphql information to the authentication backend. Usually called by
        login_mutation_body
        :param mutation_instance: graphql root
        :param info: graphql info
        :param args: graphql args
        :param kwargs: graphql kwargs
        :return: the user authenticated
        :raises Exception: if the user cannot be authenticated
        """
        request = info.context
        # We are trying to authenticate via a login mutation
        request.are_we_authenticating_from_login_mutation = True
        # Call django to authenticate the user
        user = authenticate(
            root=mutation_instance,
            request=request,
            info=info,
            *args,
            **kwargs
        )
        if user is None:
            self.authentication_failed(mutation_instance, info, *args, **kwargs)
        request.authenticated_user = user
        request.user = user
        return user

    @abc.abstractmethod
    def _on_login_mutation_output_computed(self, user, root, info, result, *args, **kwargs):
        """
        Code to do when we have generate the output of the login mutation. Performed only if the
        authentication succeeds
        :param user: user authenticated
        :param root: graphql root
        :param info: gfraphql info
        :param result: output of ht elogin mutation
        :param args: graphql *args
        :param kwargs: graphql **kwargs
        """
        pass

    @abc.abstractmethod
    def login_generate_mutation_output(self, mutation_instance, info, *args, **kwargs):
        """
        Function that is used to generate an instance of the muitation class. Needed in the mutate
        method
        :param mutation_instance: graphql root
        :param info: graphql info
        :param args: graphql args
        :param kwargs: graphql kwargs
        :return:
        """
        pass

    def login_mutation_body(self, mutation_instance: any, info, *args, **kwargs) -> any:
        """
        Actual body of the mutation login. You should not directly override this method, but rely
        on _perform_authentication, _login_generate_mutation_output and _on_login_mutation_output_computed
        :param mutation_instance: graphql root
        :param info: graphql info
        :param args: graphql args
        :param kwargs: graphql kwargs
        :return:
        """
        user = self._perform_authentication(mutation_instance, info, *args, **kwargs)
        result = self.login_generate_mutation_output(mutation_instance, info, *args, **kwargs)
        # now generate the payload
        return maybe_thenable((user, mutation_instance, info, user, result, args, kwargs), lambda values: self._on_login_mutation_output_computed(*values))

    def authentication_failed(self, root, info, *args, **kwargs):
        raise ValueError(f"Authentication failed.")

    # def me_query_class_name(self, context) -> str:
    #     return f"{context}Login"
    #
    # def me_query_description(self, context, mutation_class_name: str) -> str:
    #     return f"Allows you to authenticate the user for {context}"
    #
    # @abc.abstractmethod
    # def me_query_arguments(self, context) -> Dict[str, any]:
    #     pass
    #
    # @abc.abstractmethod
    # def me_query_return_type(self, context) -> type:
    #     pass
    #
    # @abc.abstractmethod
    # def me_query_return_value_name(self, context) -> str:
    #     pass
    #
    # @abc.abstractmethod
    # def me_query_body(self, root, info, *args, **kwargs):
    #     pass
    #
    # @abc.abstractmethod
    # def get_permissions_required_to_me_query(self, context) -> Union[str, List[str]]:
    #     pass

    @abc.abstractmethod
    def generate_context(self) -> any:
        """
        Callback where you can add all stuff you want to further inject custom data in the mutation/qwuery in authenticated
        graphql calls. It is call once.
        :return:
        """
        pass

    def generate_queries_and_mutations(self) -> Tuple[type, type]:
        context = self.generate_context()
        login = self._generate_login(context)
        #me = self._generate_me(context)

        return login, None

    def _generate_login(self, context) -> type:
        mutation_class_name = self.login_mutation_class_name(context)

        auth_token = GraphQLHelper.create_mutation(
            mutation_class_name=mutation_class_name,
            description=self.login_mutation_description(context, mutation_class_name),
            arguments=self._login_mutation_arguments(context),
            return_type=self._login_mutation_return_type(context),
            body=self.login_mutation_body,
        )
        return auth_token

    # def _generate_me(self, context) -> type:
    #     query_me_class_name = self.me_query_class_name(context)
    #     permission_required = self.get_permissions_required_to_me_query(context)
    #
    #     body = self.me_query_body
    #     body = self.permissions_required_decorator(permission_required)(body)
    #     body = self.login_required_decorator(body)
    #
    #     me = GraphQLHelper.create_query(
    #         query_class_name=query_me_class_name,
    #         description=self.me_query_description(context, query_me_class_name),
    #         arguments=self.me_query_arguments(context),
    #         return_type=self.me_query_return_type(context),
    #         output_name=self.me_query_return_value_name(context),
    #         body=body
    #     )
    #
    #     return me


class AbstractTokenGeneratorMutationCreator(AbstractGrapheneMutationCreator):
    """
    A graphene graphql mutation that, after authentication, generates a JWT token.

    Nothing is said about the input of the login mutation
    """

    @abc.abstractmethod
    def jwt_payload_name(self) -> str:
        """
        name of the payload item in the login mutation
        :return:
        """
        pass

    @abc.abstractmethod
    def jwt_refresh_expires_in(self) -> str:
        """
        name of the return value of the login mutation used to refresh the token
        :return:
        """
        pass

    @abc.abstractmethod
    def jwt_generated_token_name(self) -> str:
        """
        Name of the generated token by the login mutation
        :return:
        """
        pass

    @abc.abstractmethod
    def jwt_long_running_refresh_token_name(self) -> str:
        """
        name of the refresh token used for long running operations in the login mutation
        :return:
        """
        pass

    @abc.abstractmethod
    def jwt_long_running_refresh_token(self) -> bool:
        pass

    @abc.abstractmethod
    def jwt_allow_refresh(self) -> bool:
        pass

    @abc.abstractmethod
    def jwt_audience(self) -> Optional[str]:
        pass

    @abc.abstractmethod
    def jwt_issuer(self) -> Optional[str]:
        pass

    @abc.abstractmethod
    def jwt_algorithm(self) -> str:
        pass

    @abc.abstractmethod
    def jwt_secret_key(self) -> str:
        pass

    @abc.abstractmethod
    def jwt_public_key(self) -> Optional[str]:
        pass

    @abc.abstractmethod
    def jwt_private_key(self) -> Optional[str]:
        pass

    @abc.abstractmethod
    def jwt_reuse_refresh_tokens(self) -> bool:
        pass

    def jwt_refresh_token_model(self) -> type:
        return RefreshToken

    def jwt_token_expiration_time(self) -> timedelta:
        """
        time after which the token is not valid anymore
        :return:
        """
        return settings.JWT_TOKEN_EXPIRATION_TIME

    @abc.abstractmethod
    def jwt_csrf_rotation(self) -> bool:
        pass

    def get_user(self, root, info, request, *args, **kwargs):
        if hasattr(request, "user"):
            return request.user
        if hasattr(request, "authenticated_user"):
            return request.authenticated_user
        raise ValueError(f"No user found")

    def _login_mutation_return_type(self, context) -> Dict[str, any]:
        result = dict()
        result[self.jwt_payload_name()] = GenericScalar(required=True)
        result[self.jwt_generated_token_name()] = graphene.String(required=True)
        result[self.jwt_refresh_expires_in()] = graphene.Int(required=True)
        return result

    def _login_mutation_arguments(self, context) -> Dict[str, any]:
        result = super()._login_mutation_arguments(context)
        if self.jwt_long_running_refresh_token:
            result[self.jwt_long_running_refresh_token_name()] = GraphQLHelper.argument_jwt_token()
        return result

    def _on_login_mutation_output_computed(self, user, root, info, mutation_output, *args, **kwargs):
        """
        What do to if the authentiucation successeds? Use this function to agument the mutation output
        :param user: authenticated user
        :param root: graphql root
        :param info: graphql info
        :param mutation_output: instance of a class representing this mutation
        :param args: graphql args
        :param kwargs: graphql kwargs
        :return:
        """
        request = info.context
        payload_login = self._jwt_payload_handle(user, request)
        setattr(mutation_output, self.jwt_payload_name(), payload_login)

        token_login = self._jwt_encode(payload_login, request)
        setattr(mutation_output, self.jwt_generated_token_name(), token_login)

        if self.jwt_long_running_refresh_token():
            request.jwt_refresh_token = self._create_refresh_token(user)
            setattr(mutation_output, self.jwt_long_running_refresh_token_name(), request.jwt_refresh_token.get_token())

        return mutation_output

    def _create_refresh_token(self, user, refresh_token=None) -> any:
        """
        Create an instance of the refresh tokenb
        :param user: user to authentiucate
        :param refresh_token: refresh token that we need to update
        :return:
        """
        if refresh_token is not None and self.jwt_reuse_refresh_tokens():
            refresh_token.reuse()
            return refresh_token
        model_type = self.jwt_refresh_token_model()
        return model_type.objects.create(user=user)

    def _jwt_encode(self, payload, context=None):
        return jwt.encode(
            payload,
            self.jwt_private_key() or self.jwt_secret_key(),
            self.jwt_algorithm(),
        )

    def _jwt_payload_handle(self, user, request):
        username = user.get_username()

        if hasattr(username, 'pk'):
            username = username.pk

        exp = datetime.utcnow() + self.jwt_token_expiration_time()

        payload = {
            user.USERNAME_FIELD: username,
            'exp': timegm(exp.utctimetuple()),
        }

        if self.jwt_allow_refresh():
            payload['origIat'] = timegm(datetime.utcnow().utctimetuple())

        if self.jwt_audience() is not None:
            payload['aud'] = self.jwt_audience()

        if self.jwt_audience() is not None:
            payload['iss'] = self.jwt_audience()

        return payload

    def login_mutation_body(self, mutation_instance, info, *args, **kwargs):
        return csrf_rotation(self.jwt_csrf_rotation())(
            refresh_expiration(self.jwt_token_expiration_time())(
                super().login_mutation_body(mutation_instance, info, *args, **kwargs)
            )
        )

    # def me_query_arguments(self, context) -> Dict[str, any]:
    #     return {
    #         self.api_token(): GraphQLHelper.argument_jwt_token()
    #     }
    #
    # def me_query_return_type(self, context) -> type:
    #     return {
    #         self.me_query_return_value_name(context):
    #     }
    #
    # def me_query_return_value_name(self, context) -> str:
    #     return "user"
    #
    # def me_query_body(self, root, info, *args, **kwargs):
    #     pass
    #
    # def get_permissions_required_to_me_query(self, context) -> Union[str, List[str]]:
    #     pass

    def generate_context(self) -> any:
        return dict()


class AbstractAccessTokenGeneratorMutationCreator(AbstractTokenGeneratorMutationCreator, abc.ABC):
    """
    A generator that creates an api_token from an access_token.

    In the login, the mutation requires you to input an access_token and the mutation will generate
    for you an api_token. If you use it, expects in your authentication backend an access token
    """

    def access_token(self) -> str:
        """
        name of the required token used to generate an api one
        :return:
        """
        return "access_token"

    def _login_mutation_arguments(self, context) -> Dict[str, any]:
        return {
            self.access_token(): GraphQLHelper.argument_jwt_token(),
        }


# class ConfigAccessTokenGeneratorMutationCreator(AbstractAccessTokenGeneratorMutationCreator):
#     """
#     A creator that generates mutation and queries by looking at the configuration file.
#
#     """
#
#     def jwt_payload_name(self) -> str:
#         return settings.DJANGO_GRAPHQL_APITOKEN.JWT_PAYLOAD_NAME
#
#     def jwt_refresh_expires_in(self) -> str:
#         return settings.DJANGO_GRAPHQL_APITOKEN.JWT_REFRESH_EXPIRES_IN
#
#     def jwt_generated_token_name(self) -> str:
#         return super().jwt_generated_token_name()
#
#     def jwt_long_running_refresh_token_name(self) -> str:
#         return super().jwt_long_running_refresh_token_name()
#
#     def jwt_long_running_refresh_token(self) -> bool:
#         return super().jwt_long_running_refresh_token()
#
#     def jwt_allow_refresh(self) -> bool:
#         return super().jwt_allow_refresh()
#
#     def jwt_audience(self) -> Optional[str]:
#         return super().jwt_audience()
#
#     def jwt_issuer(self) -> Optional[str]:
#         return super().jwt_issuer()
#
#     def jwt_algorithm(self) -> str:
#         return super().jwt_algorithm()
#
#     def jwt_secret_key(self) -> str:
#         return super().jwt_secret_key()
#
#     def jwt_public_key(self) -> Optional[str]:
#         return super().jwt_public_key()
#
#     def jwt_private_key(self) -> Optional[str]:
#         return super().jwt_private_key()
#
#     def jwt_reuse_refresh_tokens(self) -> bool:
#         return super().jwt_reuse_refresh_tokens()
#
#     def jwt_refresh_token_model(self) -> type:
#         return super().jwt_refresh_token_model()
#
#     def token_expiration_time(self) -> timedelta:
#         return super().token_expiration_time()
#
#     def jwt_csrf_rotation(self) -> bool:
#         return super().jwt_csrf_rotation()
