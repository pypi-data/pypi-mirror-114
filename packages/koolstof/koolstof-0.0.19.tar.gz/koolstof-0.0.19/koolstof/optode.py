"""Import and parse the data files produced by the PyroScience pH optode."""

import pandas as pd
import os
import numpy as np
from scipy import stats


def pH_optode(spreadsheet, text_files_folder_path):
    """Import the txt files generated by Pyro Workbench as a pandas dataframe.
    Process data to get mean pH with a slope closest to 0. Generate table
    with results and stats."""

    # Import spreadsheet with filenames
    db = pd.read_excel(spreadsheet, skiprows=[1])

    # Create list of text files
    file_list = [
        file
        for file in os.listdir(text_files_folder_path)
        if "_".join(file.split("_")) in db.filename.values
    ]

    # Create loop to extract data
    data = {}
    for file in file_list:
        path = text_files_folder_path + "/{}/{}.txt"
        fname = path.format(file, file)
        data[file] = pd.read_table(fname, skiprows=22, encoding="unicode_escape")

    # Clean up datasets
    # Rename headers of df inside dict
    rn = {
        "Date [A Ch.1 Main]": "date",
        "Time [A Ch.1 Main]": "time",
        " dt (s) [A Ch.1 Main]": "sec",
        "pH [A Ch.1 Main]": "pH",
        "Sample Temp. (Â°C) [A Ch.1 CompT]": "temp",
    }
    for file in file_list:
        data[file].rename(rn, axis=1, inplace=True)

        # Drop useless (empty) columns
        data[file].drop(
            columns=[
                "Unnamed: 23",
                "Unnamed: 24",
                "Unnamed: 25",
                "Unnamed: 26",
                "Unnamed: 27",
                "Unnamed: 28",
                "Unnamed: 29",
            ],
            inplace=True,
        )

        # Remove last rows including nans
        L = data[file].pH.isnull()
        data[file] = data[file][~L]

        # Only keep 20 min of data (in case samples went over)
        L = data[file].sec <= 1190
        data[file] = data[file][L]

    # Make a copy of the data
    data_c = data.copy()

    # Create a table to hold the results
    results = pd.DataFrame({"filename": file_list})
    results["date"] = np.nan
    results["time"] = np.nan
    results["room_temp"] = np.nan
    results["pH_raw_mean"] = np.nan
    results["pH_raw_median"] = np.nan
    results["pH_last2min_mean"] = np.nan
    results["pH_last2min_median"] = np.nan
    results["slope"] = np.nan
    results["lowest_ix"] = np.nan
    results["pH_s0_mean"] = np.nan
    results["pH_s0_median"] = np.nan
    results["pH_s0_stderr"] = np.nan
    results["pH_s0_std"] = np.nan
    results["pH_s0_intercept"] = np.nan

    # Compute the mean and median of the last 2min of measurements
    # using all datapoints inside a sample file
    for file in file_list:
        L = data[file].sec > 480
        results.loc[results.filename == file, "pH_last2min_mean"] = data[file][
            L
        ].pH.mean()
        results.loc[results.filename == file, "pH_last2min_median"] = data[file][
            L
        ].pH.median()

        # Perform linear regression on all data inside sample file
        slope, intercept, r_value, p_value, std_err = stats.linregress(
            data_c[file].sec, data_c[file].pH
        )

        # Create column to hold slope resuts
        data[file]["slope_here"] = np.nan

        # Loop through the data to find the slope closest to 0
        for i in data[file].index[:-5]:
            print("correcting...")
            slope, intercept, r_value, p_value, std_err = stats.linregress(
                data_c[file].sec, data_c[file].pH
            )
            data_c[file] = data_c[file].drop(data_c[file].index[0])
            data_c[file].sort_values(by="sec")
            data[file].loc[i, "slope_here"] = np.abs(slope)
            print(file)

        # Find index of lowest abs slope
        lowest_ix = data[file].slope_here.idxmin()

        # Store time for pH slope 0 in df
        results.loc[results.filename == file, "time"] = data[file].time[lowest_ix][:5]

        # Store temperature for pH slope 0
        results.loc[results.filename == file, "temperature"] = data[file].temp[
            lowest_ix
        ]

        # Store the mean(raw pH) in df
        results.loc[results.filename == file, "pH_raw_mean"] = data[file].pH.mean()

        # Store the median (raw pH) in df
        results.loc[results.filename == file, "pH_raw_median"] = data[file].pH.median()

        # Store the index of the lowest absolute slope in df
        results.loc[results.filename == file, "lowest_ix"] = data[
            file
        ].slope_here.idxmin()

        # Store the slope from lowest_ix in df
        results.loc[results.filename == file, "slope"] = data[file].slope_here[
            lowest_ix
        ]

        # Store the mean (pH slope 0) in df
        results.loc[results.filename == file, "pH_s0_mean"] = (
            data[file].pH[lowest_ix:].mean()
        )

        # Store the median (pH slope 0) in df
        results.loc[results.filename == file, "pH_s0_median"] = (
            data[file].pH[lowest_ix:].median()
        )

        # Store the standard error for pH slope 0 in df
        results.loc[results.filename == file, "pH_s0_stderr"] = stats.linregress(
            data[file].sec[lowest_ix:], data[file].pH[lowest_ix:]
        )[4]
        # Store the standard deviation for pH slope 0 in df
        results.loc[results.filename == file, "pH_s0_std"] = (
            data[file].pH[lowest_ix:]
        ).std()

        # Store the intercept for pH slope 0 in df
        results.loc[results.filename == file, "pH_s0_intercept"] = stats.linregress(
            data[file].sec[lowest_ix:], data[file].pH[lowest_ix:]
        )[1]
        # Add useful information
        results.loc[results.filename == file, "date"] = db.date
        results.loc[results.filename == file, "room_temp"] = db.room_temp

    return results
