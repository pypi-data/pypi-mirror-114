# AUTOGENERATED! DO NOT EDIT! File to edit: 00_core.ipynb (unless otherwise specified).

__all__ = ['download_url', 'path_stats', 'checks_module', 'read_checks', 'check', 'update_checks', 'download_and_check',
           'FastDownload']

# Cell
from fastprogress.fastprogress import progress_bar
from fastcore.imports import *
from fastcore.basics import *
from fastcore.foundation import *
from fastcore.net import *
from fastcore.xtras import untar_dir
import hashlib,shutil
from pprint import pformat

# Cell
def download_url(url, dest=None):
    "Download `url` to `dest` and show progress"
    pbar = progress_bar([])
    def progress(count=1, bsize=1, tsize=None):
        pbar.total = tsize
        pbar.update(count*bsize)
    return urlsave(url, dest, reporthook=progress)

# Cell
def path_stats(fpath):
    "`True` if size and hash of `fpath` matches `size_check` and `hash_check`"
    size = os.path.getsize(fpath)
    # Just use first 1MB of file for performance
    with open(fpath, "rb") as f: hashed = hashlib.md5(f.read(2**20)).hexdigest()
    return size,hashed

# Cell
def checks_module(module):
    "Location of `download_checks.py`"
    if not module: return {}
    return Path(module.__file__).parent/'download_checks.py'

# Cell
def read_checks(fmod):
    "Evaluated contents of `download_checks.py`"
    if not fmod.exists(): return {}
    txt = fmod.read_text()
    return eval(txt) if txt else {}

# Cell
def check(fmod, url, fpath):
    "Check whether size and hash of `fpath` matches stored data for `url` or data is missing"
    checks = read_checks(fmod).get(url)
    return not checks or path_stats(fpath)==checks

# Cell
def update_checks(fpath, url, fmod):
    "Store the hash and size of `fpath` for `url` in `download_checks.py`"
    checks = read_checks(fmod)
    checks[url] = path_stats(fpath)
    fmod.write_text(pformat(checks))

# Cell
def download_and_check(url, fpath, fmod, force):
    "Download `url` to `fpath`, unless exists and `check` fails and not `force`"
    if not force and fpath.exists():
        if check(fmod, url, fpath): return fpath,force
        else:
            print("Downloading a new version of this dataset...")
            force=True
    res = download_url(url, fpath)
    if not check(fmod, url, fpath): raise Exception("Downloaded file is corrupt or not latest version")
    return res,force

# Cell
class FastDownload:
    def __init__(self, cfg=None, base='~/.fastdownload', archive=None, data=None, module=None):
        base = Path(base).expanduser().absolute()
        default = {'data':base/(data or 'data'), 'archive':base/(archive or 'archive')}
        self.cfg = Config(base, 'config.ini', create=default) if cfg is None else cfg
        self.module = checks_module(module)
        self.data_path = Path(data    or self.cfg.data)
        self.arch_path = Path(archive or self.cfg.archive)

    def check(self, url, fpath):
        "Check whether size and hash of `fpath` matches stored data for `url` or data is missing"
        checks = read_checks(self.module).get(url)
        return not checks or path_stats(fpath)==checks

    def download(self, url, force=False):
        "Download `url` to archive path, unless exists and `self.check` fails and not `force`"
        self.arch_path.mkdir(exist_ok=True, parents=True)
        res,force = download_and_check(url, urldest(url, self.arch_path), self.module, force)
        if force: self.rm()
        return res

    def rm(self, url, rm_arch=True, rm_data=True):
        "Delete downloaded archive and extracted data for `url`"
        arch = urldest(url, self.arch_path)
        data = self.data_path/remove_suffix(arch.stem, '.tar')
        if rm_data: data.delete()
        if rm_arch: arch.delete()

    def update(self, url):
        "Store the hash and size in `download_checks.py`"
        update_checks(urldest(url, self.arch_path), url, self.module)

    def extract(self, url, extract_key=None, force=False):
        "Extract archive already downloaded from `url`, overwriting existing if `force`"
        arch = urldest(url, self.arch_path)
        if not fpath.exists(): raise Exception(f'{fpath} does not exist')
        dest = self.cfg.config_path/self.cfg[extract_key] if extract_key else self.data_path
        dest.mkdir(exist_ok=True, parents=True)
        return untar_dir(arch, dest, rename=True, overwrite=force)

    def get(self, url, extract_key='data', force=False):
        "Download and extract `url`, overwriting existing if `force`"
        self.download(url, force=force)
        return self.extract(url, extract_key=extract_key, force=force)